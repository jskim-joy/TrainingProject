var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
import { reactive, resolveComponent, openBlock, createElementBlock, normalizeClass, Fragment, renderList, createElementVNode, withKeys, createBlock, withModifiers, createCommentVNode, renderSlot, createVNode, withCtx, mergeProps, toHandlers, createTextVNode, toDisplayString, TransitionGroup, Transition, normalizeStyle, resolveDynamicComponent, withDirectives, createSlots, vShow, vModelText, vModelDynamic, resolveDirective, KeepAlive } from "vue";
const config = reactive({
  breakpoints: {
    xs: 600,
    sm: 900,
    md: 1200,
    lg: 1700,
    xl: 9999
  },
  css: {
    colorShades: true,
    breakpointSpaces: false,
    breakpointLayoutClasses: true,
    grid: 12
  },
  colors: {
    primary: "#234781",
    secondary: "#d3ebff",
    success: "#54b946",
    error: "#f65555",
    warning: "#f80",
    info: "#3d9ff5"
  },
  icons: [],
  iconsLigature: false,
  notificationManager: {
    align: "right",
    transition: "default"
  },
  presets: {}
});
const mergeConfig = (options, conf = config) => {
  for (const key in options) {
    const option = options[key];
    if (typeof option === "object")
      mergeConfig(options[key], conf[key]);
    else
      conf[key] = option;
  }
};
const _NotificationManager$1 = class {
  constructor() {
    __publicField(this, "notifications");
    __publicField(this, "_uid");
    __publicField(this, "_notificationDefaults");
    if (_NotificationManager$1.instance)
      return _NotificationManager$1.instance;
    _NotificationManager$1.instance = this;
    this.notifications = [];
    this._uid = 0;
    this._notificationDefaults = {
      _uid: 0,
      _value: true,
      message: "",
      timeout: 4e3,
      dismiss: true
    };
  }
  notify(...args) {
    let notification = { ...this._notificationDefaults, _uid: this._uid++ };
    if (typeof args[0] === "object")
      notification = { ...notification, ...args[0] };
    else {
      const [message, type, timeout] = args;
      notification = {
        ...notification,
        message: message || "",
        [type === void 0 ? "info" : type]: true,
        timeout: timeout || timeout === 0 ? parseFloat(timeout) : 4e3
      };
    }
    this.notifications.push(notification);
    if (~~notification.timeout !== 0)
      setTimeout(() => this.dismiss(notification._uid), notification.timeout);
  }
  dismiss(uid) {
    this.notifications = this.notifications.filter((item) => item._uid !== uid);
  }
};
let NotificationManager$1 = _NotificationManager$1;
__publicField(NotificationManager$1, "instance");
var colors = [
  {
    label: "pink",
    color: "#e91e63",
    shades: [
      { label: "pink-light5", color: "#fce3ec" },
      { label: "pink-light4", color: "#f8bcd1" },
      { label: "pink-light3", color: "#f594b5" },
      { label: "pink-light2", color: "#f16d9a" },
      { label: "pink-light1", color: "#ed457e" },
      { label: "pink-dark1", color: "#d41556" },
      { label: "pink-dark2", color: "#b8124a" },
      { label: "pink-dark3", color: "#9c0f3f" },
      { label: "pink-dark4", color: "#800d34" },
      { label: "pink-dark5", color: "#640a29" }
    ]
  },
  {
    label: "purple",
    color: "#a741b9",
    shades: [
      { label: "purple-light5", color: "#f5e8f7" },
      { label: "purple-light4", color: "#e6c6eb" },
      { label: "purple-light3", color: "#d6a4df" },
      { label: "purple-light2", color: "#c783d3" },
      { label: "purple-light1", color: "#b861c7" },
      { label: "purple-dark1", color: "#9339a2" },
      { label: "purple-dark2", color: "#7e318c" },
      { label: "purple-dark3", color: "#6a2975" },
      { label: "purple-dark4", color: "#55215e" },
      { label: "purple-dark5", color: "#411948" }
    ]
  },
  {
    label: "deep-purple",
    color: "#673ab7",
    shades: [
      { label: "deep-purple-light5", color: "#e8e1f5" },
      { label: "deep-purple-light4", color: "#cebeea" },
      { label: "deep-purple-light3", color: "#b49bdf" },
      { label: "deep-purple-light2", color: "#9a78d4" },
      { label: "deep-purple-light1", color: "#7f56c9" },
      { label: "deep-purple-dark1", color: "#5a33a0" },
      { label: "deep-purple-dark2", color: "#4d2b89" },
      { label: "deep-purple-dark3", color: "#402471" },
      { label: "deep-purple-dark4", color: "#331d5a" },
      { label: "deep-purple-dark5", color: "#261543" }
    ]
  },
  {
    label: "indigo",
    color: "#3f51b5",
    shades: [
      { label: "indigo-light5", color: "#e4e7f6" },
      { label: "indigo-light4", color: "#c2c8ea" },
      { label: "indigo-light3", color: "#a0a9de" },
      { label: "indigo-light2", color: "#7e8bd2" },
      { label: "indigo-light1", color: "#5c6cc6" },
      { label: "indigo-dark1", color: "#37479e" },
      { label: "indigo-dark2", color: "#2f3d88" },
      { label: "indigo-dark3", color: "#273371" },
      { label: "indigo-dark4", color: "#1f285a" },
      { label: "indigo-dark5", color: "#171e44" }
    ]
  },
  {
    label: "blue",
    color: "#2196f3",
    shades: [
      { label: "blue-light5", color: "#e3f2fd" },
      { label: "blue-light4", color: "#bcdffb" },
      { label: "blue-light3", color: "#95cdf9" },
      { label: "blue-light2", color: "#6ebbf7" },
      { label: "blue-light1", color: "#48a8f5" },
      { label: "blue-dark1", color: "#0d87e9" },
      { label: "blue-dark2", color: "#0b76cc" },
      { label: "blue-dark3", color: "#0966af" },
      { label: "blue-dark4", color: "#085592" },
      { label: "blue-dark5", color: "#064475" }
    ]
  },
  {
    label: "light-blue",
    color: "#03a9f4",
    shades: [
      { label: "light-blue-light5", color: "#def4ff" },
      { label: "light-blue-light4", color: "#b1e6fe" },
      { label: "light-blue-light3", color: "#83d7fd" },
      { label: "light-blue-light2", color: "#56c9fd" },
      { label: "light-blue-light1", color: "#29bafc" },
      { label: "light-blue-dark1", color: "#0394d6" },
      { label: "light-blue-dark2", color: "#027fb8" },
      { label: "light-blue-dark3", color: "#026a99" },
      { label: "light-blue-dark4", color: "#02557b" },
      { label: "light-blue-dark5", color: "#01405d" }
    ]
  },
  {
    label: "cyan",
    color: "#04cbe5",
    shades: [
      { label: "cyan-light5", color: "#d0f9fe" },
      { label: "cyan-light4", color: "#a3f3fd" },
      { label: "cyan-light3", color: "#76edfd" },
      { label: "cyan-light2", color: "#49e7fc" },
      { label: "cyan-light1", color: "#1ce1fb" },
      { label: "cyan-dark1", color: "#03b0c7" },
      { label: "cyan-dark2", color: "#0396a9" },
      { label: "cyan-dark3", color: "#027b8b" },
      { label: "cyan-dark4", color: "#02606d" },
      { label: "cyan-dark5", color: "#01464f" }
    ]
  },
  {
    label: "teal",
    color: "#1db3a8",
    shades: [
      { label: "teal-light5", color: "#d7f8f6" },
      { label: "teal-light4", color: "#abf1ec" },
      { label: "teal-light3", color: "#7feae2" },
      { label: "teal-light2", color: "#53e3d9" },
      { label: "teal-light1", color: "#27dccf" },
      { label: "teal-dark1", color: "#19998f" },
      { label: "teal-dark2", color: "#147e77" },
      { label: "teal-dark3", color: "#10645e" },
      { label: "teal-dark4", color: "#0c4a45" },
      { label: "teal-dark5", color: "#082f2c" }
    ]
  },
  {
    label: "green",
    color: "#4caf50",
    shades: [
      { label: "green-light5", color: "#def1df" },
      { label: "green-light4", color: "#c0e4c2" },
      { label: "green-light3", color: "#a3d7a5" },
      { label: "green-light2", color: "#85ca88" },
      { label: "green-light1", color: "#68bd6b" },
      { label: "green-dark1", color: "#439a46" },
      { label: "green-dark2", color: "#39843c" },
      { label: "green-dark3", color: "#306f33" },
      { label: "green-dark4", color: "#275a29" },
      { label: "green-dark5", color: "#1e441f" }
    ]
  },
  {
    label: "light-green",
    color: "#90d73f",
    shades: [
      { label: "light-green-light5", color: "#f2fae8" },
      { label: "light-green-light4", color: "#def3c6" },
      { label: "light-green-light3", color: "#cbeca4" },
      { label: "light-green-light2", color: "#b7e583" },
      { label: "light-green-light1", color: "#a4de61" },
      { label: "light-green-dark1", color: "#81cd2b" },
      { label: "light-green-dark2", color: "#71b325" },
      { label: "light-green-dark3", color: "#619a20" },
      { label: "light-green-dark4", color: "#51811b" },
      { label: "light-green-dark5", color: "#416716" }
    ]
  },
  {
    label: "lime",
    color: "#cee029",
    shades: [
      { label: "lime-light5", color: "#f7fadb" },
      { label: "lime-light4", color: "#eff5b8" },
      { label: "lime-light3", color: "#e6ef94" },
      { label: "lime-light2", color: "#deea70" },
      { label: "lime-light1", color: "#d6e54d" },
      { label: "lime-dark1", color: "#bccd1e" },
      { label: "lime-dark2", color: "#a3b21a" },
      { label: "lime-dark3", color: "#8b9716" },
      { label: "lime-dark4", color: "#727d12" },
      { label: "lime-dark5", color: "#5a620e" }
    ]
  },
  {
    label: "yellow",
    color: "#ffe70f",
    shades: [
      { label: "yellow-light5", color: "#fffbdb" },
      { label: "yellow-light4", color: "#fff7b2" },
      { label: "yellow-light3", color: "#fff389" },
      { label: "yellow-light2", color: "#ffef61" },
      { label: "yellow-light1", color: "#ffeb38" },
      { label: "yellow-dark1", color: "#efd700" },
      { label: "yellow-dark2", color: "#d1bc00" },
      { label: "yellow-dark3", color: "#b2a000" },
      { label: "yellow-dark4", color: "#948500" },
      { label: "yellow-dark5", color: "#756900" }
    ]
  },
  {
    label: "amber",
    color: "#ffc107",
    shades: [
      { label: "amber-light5", color: "#fff6db" },
      { label: "amber-light4", color: "#ffebb0" },
      { label: "amber-light3", color: "#ffe186" },
      { label: "amber-light2", color: "#ffd65c" },
      { label: "amber-light1", color: "#ffcc31" },
      { label: "amber-dark1", color: "#e7ae00" },
      { label: "amber-dark2", color: "#c99700" },
      { label: "amber-dark3", color: "#aa8000" },
      { label: "amber-dark4", color: "#8c6900" },
      { label: "amber-dark5", color: "#6d5200" }
    ]
  },
  {
    label: "orange",
    color: "#ff9800",
    shades: [
      { label: "orange-light5", color: "#fff0d9" },
      { label: "orange-light4", color: "#ffdead" },
      { label: "orange-light3", color: "#ffcd82" },
      { label: "orange-light2", color: "#ffbb57" },
      { label: "orange-light1", color: "#ffaa2b" },
      { label: "orange-dark1", color: "#e08600" },
      { label: "orange-dark2", color: "#c27400" },
      { label: "orange-dark3", color: "#a36100" },
      { label: "orange-dark4", color: "#854f00" },
      { label: "orange-dark5", color: "#663d00" }
    ]
  },
  {
    label: "deep-orange",
    color: "#ff6825",
    shades: [
      { label: "deep-orange-light5", color: "#ffe4d8" },
      { label: "deep-orange-light4", color: "#ffcbb4" },
      { label: "deep-orange-light3", color: "#ffb290" },
      { label: "deep-orange-light2", color: "#ff996c" },
      { label: "deep-orange-light1", color: "#ff8149" },
      { label: "deep-orange-dark1", color: "#ff5306" },
      { label: "deep-orange-dark2", color: "#e74700" },
      { label: "deep-orange-dark3", color: "#c83e00" },
      { label: "deep-orange-dark4", color: "#aa3400" },
      { label: "deep-orange-dark5", color: "#8b2b00" }
    ]
  },
  {
    label: "red",
    color: "#fa3317",
    shades: [
      { label: "red-light5", color: "#fee3df" },
      { label: "red-light4", color: "#fdbfb7" },
      { label: "red-light3", color: "#fd9c8f" },
      { label: "red-light2", color: "#fc7967" },
      { label: "red-light1", color: "#fb563f" },
      { label: "red-dark1", color: "#ed2205" },
      { label: "red-dark2", color: "#cf1d04" },
      { label: "red-dark3", color: "#b11904" },
      { label: "red-dark4", color: "#931503" },
      { label: "red-dark5", color: "#751103" }
    ]
  },
  {
    label: "brown",
    color: "#845848",
    shades: [
      { label: "brown-light5", color: "#ede2de" },
      { label: "brown-light4", color: "#dbc5bd" },
      { label: "brown-light3", color: "#c9a89c" },
      { label: "brown-light2", color: "#b78b7b" },
      { label: "brown-light1", color: "#a56e5a" },
      { label: "brown-dark1", color: "#704b3d" },
      { label: "brown-dark2", color: "#5c3e32" },
      { label: "brown-dark3", color: "#493028" },
      { label: "brown-dark4", color: "#35231d" },
      { label: "brown-dark5", color: "#211612" }
    ]
  },
  {
    label: "blue-grey",
    color: "#6c8693",
    shades: [
      { label: "blue-grey-light5", color: "#e2e7e9" },
      { label: "blue-grey-light4", color: "#cad3d8" },
      { label: "blue-grey-light3", color: "#b3c0c7" },
      { label: "blue-grey-light2", color: "#9badb6" },
      { label: "blue-grey-light1", color: "#8499a4" },
      { label: "blue-grey-dark1", color: "#5f7681" },
      { label: "blue-grey-dark2", color: "#526670" },
      { label: "blue-grey-dark3", color: "#45565e" },
      { label: "blue-grey-dark4", color: "#38464c" },
      { label: "blue-grey-dark5", color: "#2b363b" }
    ]
  },
  {
    label: "grey",
    color: "#848484",
    shades: [
      { label: "grey-light5", color: "#eaeaea" },
      { label: "grey-light4", color: "#d6d6d6" },
      { label: "grey-light3", color: "#c1c1c1" },
      { label: "grey-light2", color: "#adadad" },
      { label: "grey-light1", color: "#989898" },
      { label: "grey-dark1", color: "#757575" },
      { label: "grey-dark2", color: "#656565" },
      { label: "grey-dark3", color: "#565656" },
      { label: "grey-dark4", color: "#474747" },
      { label: "grey-dark5", color: "#383838" }
    ]
  }
];
const shadeColor = (col, amt) => {
  return "#" + col.slice(1).match(/../g).map((x) => (x = +`0x${x}` + amt, x < 0 ? 0 : x > 255 ? 255 : x).toString(16).padStart(2, 0)).join("");
};
let notificationManager = null;
const _WaveUI = class {
  constructor(app, options = {}) {
    __publicField(this, "breakpoint", {
      name: "",
      xs: false,
      sm: false,
      md: false,
      lg: false,
      xl: false
    });
    __publicField(this, "colors", colors.reduce((obj, color) => {
      obj[color.label] = color.color;
      color.shades.forEach((shade) => obj[shade.label] = shade.color);
      return obj;
    }, { ...config.colors, black: "#000", white: "#fff", transparent: "transparent", inherit: "inherit" }));
    __publicField(this, "config", {});
    if (_WaveUI.instance)
      return _WaveUI.instance;
    else {
      if (!_WaveUI.registered)
        app.use(_WaveUI);
      notificationManager = reactive(new NotificationManager$1());
      mergeConfig(options);
      if (config.css.colorShades) {
        config.colorShades = {};
        for (let color in config.colors) {
          color = { label: color, color: config.colors[color].replace("#", "") };
          const col = color.color;
          if (col.length === 3)
            color.color = col[0] + "" + col[0] + col[1] + col[1] + col[2] + col[2];
          this.colors[color.label] = `#${color.color}`;
          for (let i = 1; i <= 3; i++) {
            const lighterColor = shadeColor(`#${color.color}`, i * 40);
            const darkerColor = shadeColor(`#${color.color}`, -i * 40);
            this.colors[`${color.label}-light${i}`] = lighterColor;
            this.colors[`${color.label}-dark${i}`] = darkerColor;
            config.colorShades[`${color.label}-light${i}`] = lighterColor;
            config.colorShades[`${color.label}-dark${i}`] = darkerColor;
          }
        }
      }
      this.config = config;
      this.notify = (...args) => notificationManager.notify(...args);
      _WaveUI.instance = this;
      app.config.globalProperties.$waveui = reactive(this);
      app.provide("$waveui", _WaveUI.instance);
    }
  }
  static install(app, options = {}) {
    app.directive("focus", {
      mounted: (el) => el.focus()
    });
    app.directive("scroll", {
      mounted: (el, binding) => {
        const f = (evt) => {
          if (binding.value(evt, el))
            window.removeEventListener("scroll", f);
        };
        window.addEventListener("scroll", f);
      }
    });
    const { components: components2 = {} } = options || {};
    for (let id in components2) {
      const component = components2[id];
      app.component(component.name, component);
    }
    _WaveUI.registered = true;
  }
  notify(...args) {
    notificationManager.notify(...args);
  }
};
let WaveUI = _WaveUI;
__publicField(WaveUI, "instance", null);
__publicField(WaveUI, "vueInstance", null);
const _hoisted_1$r = ["aria-expanded"];
const _hoisted_2$d = ["onClick", "onFocus", "onKeypress", "tabindex"];
const _hoisted_3$b = ["innerHTML"];
const _hoisted_4$9 = ["innerHTML"];
function render$P(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_w_button = resolveComponent("w-button");
  const _component_w_transition_expand = resolveComponent("w-transition-expand");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["w-accordion", $options.accordionClasses])
  }, [
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.accordionItems, (item, i) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["w-accordion__item", $options.itemClasses(item)]),
        key: i,
        "aria-expanded": item._expanded ? "true" : "false"
      }, [
        createElementVNode("div", {
          class: normalizeClass(["w-accordion__item-title", $props.titleClass]),
          onClick: ($event) => !item._disabled && $options.toggleItem(item, $event),
          onFocus: ($event) => _ctx.$emit("focus", $options.getOriginalItem(item)),
          onKeypress: withKeys(($event) => !item._disabled && $options.toggleItem(item, $event), ["enter"]),
          tabindex: !item._disabled && 0
        }, [
          $props.expandIcon && !$props.expandIconRight ? (openBlock(), createBlock(_component_w_button, {
            key: 0,
            class: normalizeClass(["w-accordion__expand-icon", { "w-accordion__expand-icon--expanded": item._expanded }]),
            icon: item._expanded && $props.collapseIcon || $props.expandIcon,
            disabled: item._disabled || null,
            tabindex: -1,
            text: "",
            onKeypress: _cache[0] || (_cache[0] = withModifiers(() => {
            }, ["stop"])),
            onClick: withModifiers(($event) => !item._disabled && $options.toggleItem(item, $event), ["stop"])
          }, null, 8, ["icon", "disabled", "onClick", "class"])) : createCommentVNode("", true),
          _ctx.$slots[`item-title.${item.id || i + 1}`] ? renderSlot(_ctx.$slots, `item-title.${item.id || i + 1}`, {
            key: 1,
            item: $options.getOriginalItem(item),
            expanded: item._expanded,
            index: i + 1
          }) : renderSlot(_ctx.$slots, "item-title", {
            key: 2,
            item: $options.getOriginalItem(item),
            expanded: item._expanded,
            index: i + 1
          }, () => [
            createElementVNode("div", {
              class: "grow",
              innerHTML: item[$props.itemTitleKey]
            }, null, 8, _hoisted_3$b)
          ]),
          $props.expandIcon && $props.expandIconRight ? (openBlock(), createBlock(_component_w_button, {
            key: 3,
            class: normalizeClass(["w-accordion__expand-icon", { "w-accordion__expand-icon--expanded": item._expanded }]),
            icon: item._expanded && $props.collapseIcon || $props.expandIcon,
            text: "",
            onKeypress: _cache[1] || (_cache[1] = withModifiers(() => {
            }, ["stop"])),
            onClick: withModifiers(($event) => !item._disabled && $options.toggleItem(item, $event), ["stop"])
          }, null, 8, ["icon", "onClick", "class"])) : createCommentVNode("", true)
        ], 42, _hoisted_2$d),
        createVNode(_component_w_transition_expand, {
          y: "",
          onAfterLeave: ($event) => $options.onEndOfCollapse(item),
          duration: $props.duration
        }, {
          default: withCtx(() => [
            item._expanded ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: normalizeClass(["w-accordion__item-content", $props.contentClass])
            }, [
              _ctx.$slots[`item-content.${item.id || i + 1}`] ? renderSlot(_ctx.$slots, `item-content.${item.id || i + 1}`, {
                key: 0,
                item: $options.getOriginalItem(item),
                expanded: item._expanded,
                index: i + 1
              }) : renderSlot(_ctx.$slots, "item-content", {
                key: 1,
                item: $options.getOriginalItem(item),
                expanded: item._expanded,
                index: i + 1
              }, () => [
                createElementVNode("div", {
                  innerHTML: item[$props.itemContentKey]
                }, null, 8, _hoisted_4$9)
              ])
            ], 2)) : createCommentVNode("", true)
          ]),
          _: 2
        }, 1032, ["onAfterLeave", "duration"])
      ], 10, _hoisted_1$r);
    }), 128))
  ], 2);
}
var wAccordion_vue_vue_type_style_index_0_lang = "";
var _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};
const _sfc_main$P = {
  name: "w-accordion",
  props: {
    modelValue: { type: Array },
    color: { type: String },
    bgColor: { type: String },
    items: { type: [Array, Number], required: true },
    itemColorKey: { type: String, default: "color" },
    itemTitleKey: { type: String, default: "title" },
    itemContentKey: { type: String, default: "content" },
    itemClass: { type: String },
    titleClass: { type: String },
    contentClass: { type: String },
    expandIcon: { type: [String, Boolean], default: "wi-triangle-down" },
    expandIconRight: { type: Boolean },
    expandSingle: { type: Boolean },
    collapseIcon: { type: String },
    shadow: { type: Boolean },
    duration: { type: Number, default: 250 }
  },
  emits: ["input", "update:modelValue", "focus", "item-expand", "item-collapsed"],
  data: () => ({
    accordionItems: []
  }),
  computed: {
    accordionClasses() {
      return {
        [this.color]: this.color,
        [`${this.bgColor}--bg`]: this.bgColor,
        "w-accordion--shadow": this.shadow,
        "w-accordion--no-icon": !this.expandIcon && !this.collapseIcon,
        "w-accordion--icon-right": this.expandIcon && this.expandIconRight,
        "w-accordion--rotate-icon": this.expandIcon && !this.collapseIcon
      };
    }
  },
  methods: {
    toggleItem(item, e) {
      item._expanded = !item._expanded;
      if (this.expandSingle)
        this.accordionItems.forEach((obj) => obj._index !== item._index && (obj._expanded = false));
      const expandedItems = this.accordionItems.map((item2) => item2._expanded || false);
      this.$emit("update:modelValue", expandedItems);
      this.$emit("input", expandedItems);
      this.$emit("item-expand", { item, expanded: item._expanded });
      e.target.blur();
      setTimeout(() => e.target.focus(), 300);
    },
    onEndOfCollapse(item) {
      this.$emit("item-collapsed", { item, expanded: item._expanded });
    },
    getOriginalItem(item) {
      return this.items[item._index];
    },
    itemClasses(item) {
      return {
        [this.itemClass]: this.itemClass || null,
        "w-accordion__item--expanded": item._expanded,
        "w-accordion__item--disabled": item._disabled,
        [item[this.itemColorKey]]: item[this.itemColorKey]
      };
    },
    updateItems() {
      const items = typeof this.items === "number" ? Array(this.items).fill({}) : this.items || [];
      this.accordionItems = items.map((item, _index) => ({
        ...item,
        _index,
        _expanded: this.modelValue && this.modelValue[_index],
        _disabled: !!item.disabled
      }));
    }
  },
  created() {
    this.updateItems();
  },
  watch: {
    modelValue() {
      this.updateItems();
    },
    items: {
      handler() {
        this.updateItems();
      },
      deep: true
    }
  }
};
var wAccordion = /* @__PURE__ */ _export_sfc(_sfc_main$P, [["render", render$P]]);
const _hoisted_1$q = { class: "w-alert__content" };
function render$O(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_w_icon = resolveComponent("w-icon");
  const _component_w_button = resolveComponent("w-button");
  return $data.show ? (openBlock(), createElementBlock("div", mergeProps({
    key: 0,
    class: "w-alert"
  }, toHandlers(_ctx.$attrs, true), { class: $options.classes }), [
    $options.type || $props.icon || $props.dismiss ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
      $options.type || $props.icon ? (openBlock(), createBlock(_component_w_icon, {
        key: 0,
        class: "w-alert__icon mr2"
      }, {
        default: withCtx(() => [
          createTextVNode(toDisplayString($options.type ? $options.typeIcon : $props.icon), 1)
        ]),
        _: 1
      })) : createCommentVNode("", true),
      createElementVNode("div", _hoisted_1$q, [
        renderSlot(_ctx.$slots, "default")
      ]),
      $props.dismiss ? (openBlock(), createBlock(_component_w_button, {
        key: 1,
        class: "w-alert__dismiss",
        onClick: _cache[0] || (_cache[0] = ($event) => {
          _ctx.$emit("update:modelValue", $data.show = false);
          _ctx.$emit("input", false);
          _ctx.$emit("close", false);
        }),
        icon: "wi-cross",
        color: "inherit",
        sm: "",
        text: ""
      })) : createCommentVNode("", true)
    ], 64)) : renderSlot(_ctx.$slots, "default", { key: 1 })
  ], 16)) : createCommentVNode("", true);
}
var wAlert_vue_vue_type_style_index_0_lang = "";
const _sfc_main$O = {
  name: "w-alert",
  props: {
    modelValue: { default: true },
    color: { type: String },
    bgColor: { type: String },
    shadow: { type: Boolean },
    tile: { type: Boolean },
    round: { type: Boolean },
    icon: { type: String },
    iconOutside: { type: Boolean },
    plain: { type: Boolean },
    dismiss: { type: Boolean },
    success: { type: Boolean },
    info: { type: Boolean },
    warning: { type: Boolean },
    error: { type: Boolean },
    xs: { type: Boolean },
    sm: { type: Boolean },
    md: { type: Boolean },
    lg: { type: Boolean },
    xl: { type: Boolean },
    noBorder: { type: Boolean },
    borderLeft: { type: Boolean },
    borderRight: { type: Boolean },
    borderTop: { type: Boolean },
    borderBottom: { type: Boolean },
    outline: { type: Boolean }
  },
  emits: ["input", "update:modelValue", "close"],
  data() {
    return {
      show: this.modelValue
    };
  },
  computed: {
    typeIcon() {
      return this.type === "success" && "wi-check-circle" || this.type === "warning" && "wi-warning-circle" || this.type === "error" && "wi-cross-circle" || this.type === "info" && "wi-info-circle";
    },
    type() {
      return this.success && "success" || this.info && "info" || this.warning && "warning" || this.error && "error" || null;
    },
    presetSize() {
      return this.xs && "xs" || this.sm && "sm" || this.md && "md" || this.lg && "lg" || this.xl && "xl" || null;
    },
    hasSingleBorder() {
      return this.borderLeft || this.borderRight || this.borderTop || this.borderBottom;
    },
    classes() {
      return {
        [`${this.bgColor || this.plain && this.type}--bg w-alert--bg`]: this.bgColor || this.plain && this.type,
        [this.color || !this.plain && this.type]: this.color || !this.plain && this.type,
        [`size--${this.presetSize}`]: this.presetSize,
        [`w-alert--${this.type}`]: this.type,
        "w-alert--has-icon": this.type || this.icon || this.dismiss,
        "w-alert--icon-outside": this.iconOutside,
        "w-alert--plain": this.type && this.plain,
        "w-alert--outline": this.outline,
        "w-alert--tile": this.tile,
        "w-alert--round": this.round,
        "w-alert--no-border": this.noBorder || this.plain && this.type,
        "w-alert--one-border": this.hasSingleBorder || this.iconOutside,
        "w-alert--border-left": !this.noBorder && this.borderLeft || this.iconOutside,
        "w-alert--border-right": !this.noBorder && this.borderRight,
        "w-alert--border-top": !this.noBorder && this.borderTop,
        "w-alert--border-bottom": !this.noBorder && this.borderBottom,
        "w-alert--shadow": this.shadow
      };
    }
  },
  watch: {
    modelValue(value) {
      this.show = value;
    }
  }
};
var wAlert = /* @__PURE__ */ _export_sfc(_sfc_main$O, [["render", render$O]]);
const _hoisted_1$p = ["innerHTML"];
function render$N(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_w_alert = resolveComponent("w-alert");
  return openBlock(), createBlock(TransitionGroup, {
    class: normalizeClass(["w-notification-manager", { "w-notification-manager--left": $options.conf.align === "left" }]),
    tag: "div",
    name: $options.transition,
    appear: ""
  }, {
    default: withCtx(() => [
      (openBlock(true), createElementBlock(Fragment, null, renderList($options.notifications, (notif) => {
        return openBlock(), createElementBlock(Fragment, null, [
          notif._value ? (openBlock(), createBlock(_component_w_alert, mergeProps({
            key: 0,
            class: "white--bg",
            key: notif._uid,
            modelValue: notif._value,
            "onUpdate:modelValue": ($event) => notif._value = $event,
            onClose: ($event) => _ctx.notifManager.dismiss(notif._uid)
          }, $options.notifProps(notif)), {
            default: withCtx(() => [
              createElementVNode("div", {
                innerHTML: notif.message
              }, null, 8, _hoisted_1$p)
            ]),
            _: 2
          }, 1040, ["modelValue", "onUpdate:modelValue", "onClose"])) : createCommentVNode("", true)
        ], 64);
      }), 256))
    ]),
    _: 1
  }, 8, ["class", "name"]);
}
var wNotificationManager_vue_vue_type_style_index_0_lang = "";
const _sfc_main$N = {
  name: "w-notification-manager",
  data: () => ({
    notifManager: null
  }),
  computed: {
    conf() {
      return this.$waveui.config.notificationManager;
    },
    notifications() {
      var _a;
      return ((_a = this.notifManager) == null ? void 0 : _a.notifications) || [];
    },
    transition() {
      return this.conf.transition ? this.conf.transition.replace("default", `slide-${this.conf.align === "left" ? "right" : "left"}`) : "";
    }
  },
  methods: {
    notifProps(notif) {
      const { _value, _uid, message, timeout, ...props } = notif;
      return props;
    }
  },
  created() {
    this.notifManager = new NotificationManager$1();
  },
  beforeUnmount() {
    this.notifManager.notifications = [];
    delete this.notifManager;
  }
};
var NotificationManager = /* @__PURE__ */ _export_sfc(_sfc_main$N, [["render", render$N]]);
const cssVars = {
  cssScope: ".w-app",
  baseIncrement: 4
};
const generateColors = (config2) => {
  let styles = "";
  const { cssScope } = cssVars;
  const { info, warning, success, error, ...colors2 } = config2.colors;
  for (const color in colors2) {
    styles += `${cssScope} .${color}--bg{background-color:${config2.colors[color]}}${cssScope} .${color}{color:${config2.colors[color]}}`;
  }
  if (config2.css.colorShades && config2.colorShades) {
    Object.entries(config2.colorShades).forEach(([label, color]) => {
      styles += `${cssScope} .${label}--bg{background-color:${color}}${cssScope} .${label}{color:${color}}`;
    });
  }
  const statusColors = { info, warning, success, error };
  for (const color in statusColors) {
    styles += `${cssScope} .${color}--bg{background-color:${config2.colors[color]}}${cssScope} .${color}{color:${config2.colors[color]}}`;
  }
  const cssVariables = [];
  cssVariables.push(`--primary: ${config2.colors.primary}`);
  styles += `:root {${cssVariables.join(";")}}`;
  return styles;
};
const generateBreakpoints = (breakpoints, grid) => {
  let styles = "";
  const { cssScope } = cssVars;
  breakpoints.forEach(({ min, label }) => {
    if (label === "xs") {
      for (let i = 0; i < grid; i++) {
        styles += `${cssScope} .${label}${grid - i}{width:${parseFloat(((grid - i) * 100 / grid).toFixed(4))}%;}`;
      }
    } else {
      styles += `@media(min-width:${min}px){`;
      for (let i = 0; i < grid; i++) {
        styles += `${cssScope} .${label}${grid - i}{width:${parseFloat(((grid - i) * 100 / grid).toFixed(4))}%;}`;
      }
      styles += "}";
    }
  });
  return styles;
};
const genBreakpointLayoutClasses = (breakpoints) => {
  let styles = "";
  const { cssScope, baseIncrement } = cssVars;
  const layoutClasses = [
    "show{display:block}",
    "hide{display:none}",
    "d-flex{display:flex}",
    "d-iflex{display:inline-flex}",
    "d-block{display:block}",
    "d-iblock{display:inline-block}",
    "text-left{text-align:left}",
    "text-center{text-align:center}",
    "text-right{text-align:right}",
    "text-nowrap{whitespace:nowrap}",
    "row{flex-direction:row}",
    "column{flex-direction:column}",
    "grow{flex-grow:1;flex-basis:auto}",
    "no-grow{flex-grow:0}",
    "shrink{flex-shrink:1;margin-left:auto;margin-right:auto}",
    "no-shrink{flex-shrink:0}",
    "fill-width{width:100%}",
    "fill-height{height:100%}",
    "basis-zero{flex-basis:0}",
    "align-start{align-items:flex-start}",
    "align-center{align-items:center}",
    "align-end{align-items:flex-end}",
    "align-self-start{align-self:flex-start}",
    "align-self-center{align-self:center}",
    "align-self-end{align-self:flex-end}",
    "align-self-stretch{align-self:stretch}",
    "justify-start{justify-content:flex-start}",
    "justify-center{justify-content:center}",
    "justify-end{justify-content:flex-end}",
    "justify-space-between{justify-content:space-between}",
    "justify-space-around{justify-content:space-around}",
    "justify-space-evenly{justify-content:space-evenly}"
  ];
  const array12 = Array(12).fill();
  breakpoints.forEach(({ label, min }) => {
    if (label !== "xs") {
      styles += `@media(min-width:${min}px){` + layoutClasses.map((rule) => `${cssScope} .${label}u-${rule}`).join("") + array12.map((item, i) => `.w-grid.${label}u-columns${i + 1}{grid-template-columns:repeat(${i + 1},1fr);}`).join("") + array12.map((item, i) => `.w-flex.${label}u-gap${i + 1},.w-grid.${label}u-gap${i + 1}{gap:${(i + 1) * baseIncrement}px;}`).join("") + `.w-flex.${label}u-gap0,.w-flex.${label}u-gap0{gap:0}}`;
    }
  });
  breakpoints.forEach(({ label, min, max }) => {
    styles += `@media (min-width:${min}px) and (max-width:${max}px){` + layoutClasses.map((rule) => `${cssScope} .${label}-${rule}`).join("") + array12.map((item, i) => `.w-grid.${label}-columns${i + 1}{grid-template-columns:repeat(${i + 1},1fr);}`).join("") + array12.map((item, i) => `.w-flex.${label}-gap${i + 1},.w-grid.${label}-gap${i + 1}{gap:${(i + 1) * baseIncrement}px;}`).join("") + `.w-flex.${label}-gap0,.w-flex.${label}-gap0{gap:0}}`;
  });
  breakpoints.forEach(({ label, max }) => {
    if (label !== "xl") {
      styles += `@media (max-width:${max}px){` + layoutClasses.map((rule) => `${cssScope} .${label}d-${rule}`).join("") + array12.map((item, i) => `.w-grid.${label}d-columns${i + 1}{grid-template-columns:repeat(${i + 1},1fr);}`).join("") + array12.map((item, i) => `.w-flex.${label}d-gap${i + 1},.w-grid.${label}d-gap${i + 1}{gap:${(i + 1) * baseIncrement}px;}`).join("") + `.w-flex.${label}d-gap0,.w-flex.${label}d-gap0{gap:0}}`;
    }
  });
  return styles;
};
var dynamicCSS = (config2) => {
  const entries = Object.entries(config2.breakpoints);
  const breakpointsDef2 = entries.map(([label, max], i) => {
    const [, value = 0] = entries[i - 1] || [];
    return { label, min: value ? value + 1 : 0, max };
  });
  const computedStyles = getComputedStyle(document.documentElement);
  cssVars.cssScope = computedStyles.getPropertyValue("--css-scope");
  cssVars.baseIncrement = parseInt(computedStyles.getPropertyValue("--base-increment"));
  let styles = "";
  styles += generateColors(config2);
  styles += generateBreakpoints(breakpointsDef2, config2.css.grid);
  if (config2.css.breakpointLayoutClasses)
    styles += genBreakpointLayoutClasses(breakpointsDef2);
  return styles;
};
function render$M(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_notification_manager = resolveComponent("notification-manager");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["w-app", $options.classes])
  }, [
    renderSlot(_ctx.$slots, "default"),
    createVNode(_component_notification_manager)
  ], 2);
}
var wApp_vue_vue_type_style_index_0_lang = "";
let breakpointsDef = { keys: [], values: [] };
const _sfc_main$M = {
  name: "w-app",
  props: {
    dark: { type: Boolean },
    block: { type: Boolean },
    row: { type: Boolean },
    alignCenter: { type: Boolean },
    alignEnd: { type: Boolean },
    justifyCenter: { type: Boolean },
    justifyEnd: { type: Boolean },
    justifySpaceBetween: { type: Boolean },
    justifySpaceAround: { type: Boolean },
    justifySpaceEvenly: { type: Boolean },
    textCenter: { type: Boolean },
    textRight: { type: Boolean }
  },
  components: { NotificationManager },
  data: () => ({
    currentBreakpoint: null,
    notifManager: null
  }),
  computed: {
    classes() {
      return {
        "d-block": this.block,
        row: this.row,
        "align-center": this.alignCenter,
        "align-end": this.alignEnd,
        "justify-center": this.justifyCenter,
        "justify-end": this.justifyEnd,
        "justify-space-between": this.justifySpaceBetween,
        "justify-space-around": this.justifySpaceAround,
        "justify-space-evenly": this.justifySpaceEvenly,
        "text-center": this.textCenter,
        "text-right": this.textRight,
        "theme--dark": this.dark
      };
    }
  },
  methods: {
    getBreakpoint() {
      const width = window.innerWidth;
      const breakpoints = breakpointsDef.values.slice(0);
      breakpoints.push(width);
      breakpoints.sort((a, b) => a - b);
      const breakpoint = breakpointsDef.keys[breakpoints.indexOf(width)] || "xl";
      if (breakpoint !== this.currentBreakpoint) {
        this.currentBreakpoint = breakpoint;
        this.$waveui.breakpoint = {
          name: breakpoint,
          xs: breakpoint === "xs",
          sm: breakpoint === "sm",
          md: breakpoint === "md",
          lg: breakpoint === "lg",
          xl: breakpoint === "xl",
          width
        };
      }
      this.$waveui.breakpoint.width = width;
    }
  },
  mounted() {
    const { config: config2 } = this.$waveui;
    breakpointsDef = { keys: Object.keys(config2.breakpoints), values: Object.values(config2.breakpoints) };
    if (!document.getElementById("wave-ui-styles")) {
      const css = document.createElement("style");
      css.id = "wave-ui-styles";
      css.innerHTML = dynamicCSS(config2);
      const firstStyle = document.head.querySelectorAll('style,link[rel="stylesheet"]')[0];
      if (firstStyle)
        firstStyle.before(css);
      else
        document.head.appendChild(css);
    }
    this.getBreakpoint(window.innerWidth);
    window.addEventListener("resize", this.getBreakpoint);
  },
  beforeUnmount() {
    window.removeEventListener("resize", this.getBreakpoint);
  }
};
var wApp = /* @__PURE__ */ _export_sfc(_sfc_main$M, [["render", render$M]]);
function render$L(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", mergeProps({ class: "w-badge-wrap" }, toHandlers(_ctx.$attrs, true)), [
    renderSlot(_ctx.$slots, "default"),
    createVNode(Transition, {
      name: `${$props.transition}`
    }, {
      default: withCtx(() => [
        $props.modelValue ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass(["w-badge", $options.classes]),
          style: normalizeStyle($options.styles),
          "aria-atomic": "true",
          "aria-label": "Badge",
          "aria-live": "polite",
          role: "status"
        }, [
          !$props.dot ? renderSlot(_ctx.$slots, "badge", { key: 0 }, () => [
            createTextVNode(toDisplayString($props.modelValue === true ? "" : $props.modelValue || ""), 1)
          ]) : createCommentVNode("", true)
        ], 6)) : createCommentVNode("", true)
      ]),
      _: 3
    }, 8, ["name"])
  ], 16);
}
var wBadge_vue_vue_type_style_index_0_lang = "";
const _sfc_main$L = {
  name: "w-badge",
  props: {
    modelValue: { default: true },
    xs: { type: Boolean },
    sm: { type: Boolean },
    md: { type: Boolean },
    lg: { type: Boolean },
    xl: { type: Boolean },
    top: { type: Boolean },
    left: { type: Boolean },
    right: { type: Boolean },
    bottom: { type: Boolean },
    overlap: { type: Boolean },
    inline: { type: Boolean },
    color: { type: String },
    size: { type: [Number, String] },
    bgColor: { type: String, default: "primary" },
    dark: { type: Boolean },
    badgeClass: { type: String },
    outline: { type: Boolean },
    shadow: { type: Boolean },
    dot: { type: Boolean },
    round: { type: Boolean },
    transition: { type: String, default: "fade" }
  },
  emits: [],
  computed: {
    forcedSize() {
      return this.size && (!isNaN(this.size) ? `${this.size}px` : this.size);
    },
    presetSize() {
      return this.xs && "xs" || this.sm && "sm" || this.md && "md" || this.lg && "lg" || this.xl && "xl" || "md";
    },
    position() {
      return [
        this.top && "top" || this.bottom && "bottom" || "top",
        this.left && "left" || this.right && "right" || "right"
      ];
    },
    classes() {
      const slotText = this.$slots.badge && this.$slots.badge().map((item) => item.children).join("");
      return {
        [this.color]: this.color,
        [`${this.bgColor}--bg`]: this.bgColor,
        [this.badgeClass]: this.badgeClass || null,
        "w-badge--round": this.round || (slotText || this.modelValue + "" || "").length < 2,
        "w-badge--dark": this.dark && !this.outline,
        "w-badge--outline": this.outline,
        "w-badge--inline": this.inline,
        "w-badge--shadow": this.shadow,
        "w-badge--overlap": this.overlap,
        "w-badge--dot": this.dot,
        [`size--${this.presetSize}`]: this.presetSize && !this.forcedSize,
        [`w-badge--${this.position.join(" w-badge--")}`]: true
      };
    },
    styles() {
      return this.forcedSize && `font-size: ${this.forcedSize}`;
    }
  }
};
var wBadge = /* @__PURE__ */ _export_sfc(_sfc_main$L, [["render", render$L]]);
const _hoisted_1$o = ["innerHTML"];
function render$K(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_w_icon = resolveComponent("w-icon");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["w-breadcrumbs", $options.classes])
  }, [
    (openBlock(true), createElementBlock(Fragment, null, renderList($props.items, (item, i) => {
      return openBlock(), createElementBlock(Fragment, null, [
        i && _ctx.$slots.separator ? (openBlock(), createElementBlock("span", {
          class: normalizeClass(["w-breadcrumbs__separator", $props.separatorColor]),
          key: `${i}a`
        }, [
          renderSlot(_ctx.$slots, "separator", { index: i })
        ], 2)) : i ? (openBlock(), createBlock(_component_w_icon, {
          class: normalizeClass(["w-breadcrumbs__separator", $props.separatorColor]),
          key: `${i}b`
        }, {
          default: withCtx(() => [
            createTextVNode(toDisplayString($props.icon), 1)
          ]),
          _: 2
        }, 1032, ["class"])) : createCommentVNode("", true),
        item[$props.itemRouteKey] && (i < $props.items.length - 1 || $props.linkLastItem) ? (openBlock(), createElementBlock(Fragment, { key: 2 }, [
          _ctx.$slots.item ? (openBlock(), createBlock(resolveDynamicComponent($options.hasRouter ? "router-link" : "a"), {
            class: normalizeClass(["w-breadcrumbs__item", $props.color || null]),
            key: `${i}c`,
            to: $options.hasRouter && item[$props.itemRouteKey],
            href: item[$props.itemRouteKey]
          }, {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "item", {
                item,
                index: i + 1,
                isLast: i === $props.items.length - 1
              })
            ]),
            _: 2
          }, 1032, ["to", "href", "class"])) : (openBlock(), createBlock(resolveDynamicComponent($options.hasRouter ? "router-link" : "a"), {
            class: normalizeClass(["w-breadcrumbs__item", $props.color || null]),
            key: `${i}d`,
            to: $options.hasRouter && item[$props.itemRouteKey],
            href: item[$props.itemRouteKey],
            innerHTML: item[$props.itemLabelKey]
          }, null, 8, ["to", "href", "innerHTML", "class"]))
        ], 64)) : _ctx.$slots.item ? renderSlot(_ctx.$slots, "item", {
          key: `${i}e`,
          item,
          index: i + 1,
          isLast: i === $props.items.length - 1
        }) : (openBlock(), createElementBlock("span", {
          key: `${i}f`,
          innerHTML: item[$props.itemLabelKey]
        }, null, 8, _hoisted_1$o))
      ], 64);
    }), 256))
  ], 2);
}
var wBreadcrumbs_vue_vue_type_style_index_0_lang = "";
const _sfc_main$K = {
  name: "w-breadcrumbs",
  props: {
    items: { type: Array, required: true },
    linkLastItem: { type: Boolean },
    color: { type: String },
    separatorColor: { type: String, default: "grey-light1" },
    icon: { type: String, default: "wi-chevron-right" },
    itemRouteKey: { type: String, default: "route" },
    itemLabelKey: { type: String, default: "label" },
    xs: { type: Boolean },
    sm: { type: Boolean },
    md: { type: Boolean },
    lg: { type: Boolean },
    xl: { type: Boolean }
  },
  emits: [],
  computed: {
    hasRouter() {
      return "$router" in this;
    },
    size() {
      return this.xs && "xs" || this.sm && "sm" || this.lg && "lg" || this.xl && "xl" || "md";
    },
    classes() {
      return {
        [`size--${this.size}`]: true
      };
    }
  }
};
var wBreadcrumbs = /* @__PURE__ */ _export_sfc(_sfc_main$K, [["render", render$K]]);
const _hoisted_1$n = {
  key: 0,
  class: "w-button__loader"
};
const _hoisted_2$c = /* @__PURE__ */ createElementVNode("svg", { viewBox: "0 0 40 40" }, [
  /* @__PURE__ */ createElementVNode("circle", {
    cx: "20",
    cy: "20",
    r: "18",
    fill: "transparent",
    stroke: "currentColor",
    "stroke-width": "4",
    "stroke-linecap": "round"
  })
], -1);
function render$J(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_w_icon = resolveComponent("w-icon");
  return openBlock(), createBlock(resolveDynamicComponent($props.route ? "a" : "button"), mergeProps({
    class: ["w-button", $options.classes],
    type: !$props.route && $props.type,
    href: $props.route && ($options.externalLink ? $props.route : $options.resolvedRoute) || null,
    disabled: !!$props.disabled || null
  }, toHandlers($options.listeners), _ctx.$attrs, { style: $options.styles }), {
    default: withCtx(() => [
      $props.icon ? (openBlock(), createBlock(_component_w_icon, { key: 0 }, {
        default: withCtx(() => [
          createTextVNode(toDisplayString($props.icon), 1)
        ]),
        _: 1
      })) : renderSlot(_ctx.$slots, "default", { key: 1 }),
      createVNode(Transition, { name: "scale-fade" }, {
        default: withCtx(() => [
          $props.loading ? (openBlock(), createElementBlock("div", _hoisted_1$n, [
            renderSlot(_ctx.$slots, "loading", {}, () => [
              _hoisted_2$c
            ])
          ])) : createCommentVNode("", true)
        ]),
        _: 3
      })
    ]),
    _: 3
  }, 16, ["type", "href", "class", "disabled", "style"]);
}
var wButton_vue_vue_type_style_index_0_lang = "";
const _sfc_main$J = {
  name: "w-button",
  props: {
    color: { type: String },
    bgColor: { type: String },
    dark: { type: Boolean },
    outline: { type: Boolean },
    text: { type: Boolean },
    round: { type: Boolean },
    shadow: { type: Boolean },
    tile: { type: Boolean },
    route: { type: [String, Object] },
    forceLink: { type: Boolean },
    type: { type: String, default: "button" },
    disabled: { type: Boolean },
    loading: { type: Boolean },
    icon: { type: String, default: null },
    absolute: { type: Boolean },
    fixed: { type: Boolean },
    top: { type: Boolean },
    bottom: { type: Boolean },
    left: { type: Boolean },
    right: { type: Boolean },
    zIndex: { type: [Number, String] },
    width: { type: [Number, String] },
    height: { type: [Number, String] },
    xs: { type: Boolean },
    sm: { type: Boolean },
    md: { type: Boolean },
    lg: { type: Boolean },
    xl: { type: Boolean }
  },
  emits: [],
  computed: {
    hasRouter() {
      return "$router" in this;
    },
    resolvedRoute() {
      return this.hasRouter ? this.$router.resolve(this.route).href : this.route;
    },
    listeners() {
      return this.route && this.hasRouter && !this.forceLink && !this.externalLink ? {
        ...this.$attrs,
        click: (e) => {
          if (this.$attrs.click)
            this.$attrs.click(e);
          this.$router.push(this.route);
          e.stopPropagation();
          e.preventDefault();
        }
      } : this.$attrs;
    },
    size() {
      return this.xs && "xs" || this.sm && "sm" || this.lg && "lg" || this.xl && "xl" || "md";
    },
    position() {
      return [
        this.top && "top" || this.bottom && "bottom" || "top",
        this.left && "left" || this.right && "right" || "right"
      ];
    },
    externalLink() {
      return /^(https?:)?\/\/|mailto:|tel:/.test(this.route);
    },
    classes() {
      return {
        "primary--bg": !this.bgColor && !this.color && !this.dark && !(this.outline || this.text),
        primary: !this.bgColor && !this.color && !this.dark && (this.outline || this.text),
        [this.color]: this.color,
        [`${this.bgColor}--bg`]: this.bgColor,
        "w-button--dark": this.dark && !this.outline,
        "w-button--outline": this.outline,
        "w-button--text": this.text,
        "w-button--round": this.round,
        "w-button--tile": this.tile,
        "w-button--shadow": this.shadow,
        "w-button--loading": this.loading,
        "w-button--icon": this.icon,
        [`size--${this.size}`]: true,
        "w-button--absolute": this.absolute,
        "w-button--fixed": this.fixed,
        [`w-button--${this.position.join(" w-button--")}`]: this.absolute || this.fixed
      };
    },
    styles() {
      return {
        width: (!isNaN(this.width) ? `${this.width}px` : this.width) || null,
        height: (!isNaN(this.height) ? `${this.height}px` : this.height) || null,
        zIndex: this.zIndex || this.zIndex === 0 || null
      };
    }
  }
};
var wButton = /* @__PURE__ */ _export_sfc(_sfc_main$J, [["render", render$J]]);
const objectifyClasses = (classes = {}) => {
  if (typeof classes === "string")
    classes = { [classes]: true };
  else if (Array.isArray(classes))
    classes = { [classes.join(" ")]: true };
  return classes;
};
function render$I(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_w_image = resolveComponent("w-image");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["w-card", $options.classes])
  }, [
    _ctx.$slots.title || $props.title ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: normalizeClass(["w-card__title", { "w-card__title--has-toolbar": _ctx.$slots.title && $options.titleHasToolbar, ...$options.titleClasses }])
    }, [
      renderSlot(_ctx.$slots, "title", {}, () => [
        createTextVNode(toDisplayString($props.title), 1)
      ])
    ], 2)) : createCommentVNode("", true),
    $props.image ? (openBlock(), createBlock(_component_w_image, mergeProps({
      key: 1,
      class: "w-card__image",
      src: $props.image
    }, $options.imgProps), {
      default: withCtx(() => [
        renderSlot(_ctx.$slots, "image-content")
      ]),
      _: 3
    }, 16, ["src"])) : createCommentVNode("", true),
    createElementVNode("div", {
      class: normalizeClass(["w-card__content", $options.contentClasses])
    }, [
      renderSlot(_ctx.$slots, "default")
    ], 2),
    _ctx.$slots.actions ? (openBlock(), createElementBlock("div", {
      key: 2,
      class: normalizeClass(["w-card__actions", { "w-card__actions--has-toolbar": $options.actionsHasToolbar }])
    }, [
      renderSlot(_ctx.$slots, "actions")
    ], 2)) : createCommentVNode("", true)
  ], 2);
}
var wCard_vue_vue_type_style_index_0_lang = "";
const _sfc_main$I = {
  name: "w-card",
  props: {
    color: { type: String },
    bgColor: { type: String },
    shadow: { type: Boolean },
    noBorder: { type: Boolean },
    tile: { type: Boolean },
    title: { type: String },
    image: { type: String },
    imageProps: { type: Object },
    titleClass: { type: [String, Object, Array] },
    contentClass: { type: [String, Object, Array] }
  },
  emits: [],
  computed: {
    titleClasses() {
      return objectifyClasses(this.titleClass);
    },
    contentClasses() {
      return objectifyClasses(this.contentClass);
    },
    titleHasToolbar() {
      const { title } = this.$slots;
      return title && title().map((vnode) => vnode.type.name).join("").includes("w-toolbar");
    },
    actionsHasToolbar() {
      const { actions } = this.$slots;
      return actions && actions().map((vnode) => vnode.type.name).join("").includes("w-toolbar");
    },
    imgProps() {
      return {
        tag: "div",
        ratio: 1 / 2,
        ...this.imageProps
      };
    },
    classes() {
      return {
        [this.color]: this.color,
        [`${this.bgColor}--bg`]: this.bgColor,
        "w-card--no-border": this.noBorder,
        "w-card--tile": this.tile,
        "w-card--shadow": this.shadow
      };
    }
  }
};
var wCard = /* @__PURE__ */ _export_sfc(_sfc_main$I, [["render", render$I]]);
var FormElementMixin = {
  inject: {
    formRegister: { default: null },
    formProps: { default: () => ({ disabled: false, readonly: false }) }
  },
  props: {
    name: { type: String },
    disabled: { type: Boolean },
    readonly: { type: Boolean },
    required: { type: Boolean },
    tabindex: { type: String },
    validators: { type: Array }
  },
  data: () => ({
    valid: null
  }),
  computed: {
    inputName() {
      return this.name || `${this.$options.name}--${this._.uid}`;
    },
    isDisabled() {
      return this.disabled || this.formProps.disabled;
    },
    isReadonly() {
      return this.readonly || this.formProps.readonly;
    },
    validationColor() {
      return this.formProps.validationColor;
    },
    labelClasses() {
      return {
        [this.labelColor]: this.labelColor && this.valid !== false,
        [this.validationColor]: this.valid === false
      };
    }
  },
  methods: {
    validate() {
      this.$refs.formEl.validate(this);
    }
  }
};
const _hoisted_1$m = ["id", "name", "checked", "disabled", "required", "tabindex", "aria-checked"];
const _hoisted_2$b = ["for"];
const _hoisted_3$a = /* @__PURE__ */ createElementVNode("svg", {
  width: "11px",
  height: "9px",
  viewbox: "0 0 12 9"
}, [
  /* @__PURE__ */ createElementVNode("polyline", { points: "1 5 4 8 10 2" })
], -1);
const _hoisted_4$8 = [
  _hoisted_3$a
];
const _hoisted_5$6 = ["for"];
function render$H(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(resolveDynamicComponent(_ctx.formRegister && !$options.wCheckboxes ? "w-form-element" : "div"), mergeProps({ ref: "formEl" }, _ctx.formRegister && { validators: _ctx.validators, inputValue: $data.isChecked, disabled: _ctx.isDisabled }, {
    valid: _ctx.valid,
    "onUpdate:valid": _cache[5] || (_cache[5] = ($event) => _ctx.valid = $event),
    onReset: _cache[6] || (_cache[6] = ($event) => {
      _ctx.$emit("update:modelValue", $data.isChecked = null);
      _ctx.$emit("input", null);
    }),
    class: $options.classes
  }), {
    default: withCtx(() => [
      createElementVNode("input", {
        ref: "input",
        id: `w-checkbox--${_ctx._.uid}`,
        type: "checkbox",
        name: _ctx.inputName,
        checked: $data.isChecked || null,
        disabled: _ctx.isDisabled || null,
        required: _ctx.required || null,
        tabindex: _ctx.tabindex || null,
        onFocus: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("focus", $event)),
        onBlur: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("blur", $event)),
        onChange: _cache[2] || (_cache[2] = ($event) => $options.onInput()),
        onKeypress: _cache[3] || (_cache[3] = withKeys((...args) => $options.onInput && $options.onInput(...args), ["enter"])),
        "aria-checked": $data.isChecked || "false",
        role: "checkbox"
      }, null, 40, _hoisted_1$m),
      $options.hasLabel && $props.labelOnLeft ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
        _ctx.$slots.default || $props.label ? (openBlock(), createElementBlock("label", {
          key: 0,
          class: normalizeClass(["w-checkbox__label w-form-el-shakable pr2", _ctx.labelClasses]),
          for: `w-checkbox--${_ctx._.uid}`
        }, [
          renderSlot(_ctx.$slots, "default", {}, () => [
            createTextVNode(toDisplayString($props.label), 1)
          ])
        ], 10, _hoisted_2$b)) : createCommentVNode("", true)
      ], 64)) : createCommentVNode("", true),
      createElementVNode("div", {
        class: normalizeClass(["w-checkbox__input", this.color]),
        onClick: _cache[4] || (_cache[4] = ($event) => {
          _ctx.$refs.input.focus();
          _ctx.$refs.input.click();
        })
      }, _hoisted_4$8, 2),
      $options.hasLabel && !$props.labelOnLeft ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
        _ctx.$slots.default || $props.label ? (openBlock(), createElementBlock("label", {
          key: 0,
          class: normalizeClass(["w-checkbox__label w-form-el-shakable pl2", _ctx.labelClasses]),
          for: `w-checkbox--${_ctx._.uid}`
        }, [
          renderSlot(_ctx.$slots, "default", {}, () => [
            createTextVNode(toDisplayString($props.label), 1)
          ])
        ], 10, _hoisted_5$6)) : createCommentVNode("", true)
      ], 64)) : createCommentVNode("", true)
    ]),
    _: 3
  }, 16, ["valid", "class"]);
}
var wCheckbox_vue_vue_type_style_index_0_lang = "";
const _sfc_main$H = {
  name: "w-checkbox",
  mixins: [FormElementMixin],
  inject: {
    wCheckboxes: { default: null }
  },
  props: {
    modelValue: { default: false },
    returnValue: {},
    label: { type: String },
    labelOnLeft: { type: Boolean },
    color: { type: String, default: "primary" },
    labelColor: { type: String, default: "primary" },
    noRipple: { type: Boolean },
    indeterminate: { type: Boolean },
    round: { type: Boolean }
  },
  emits: ["input", "update:modelValue", "focus", "blur"],
  data() {
    return {
      isChecked: this.modelValue,
      ripple: {
        start: false,
        end: false,
        timeout: null
      }
    };
  },
  computed: {
    hasLabel() {
      return this.label || this.$slots.default;
    },
    classes() {
      return {
        [`w-checkbox w-checkbox--${this.isChecked ? "checked" : "unchecked"}`]: true,
        "w-checkbox--disabled": this.isDisabled,
        "w-checkbox--indeterminate": this.indeterminate,
        "w-checkbox--ripple": this.ripple.start,
        "w-checkbox--rippled": this.ripple.end,
        "w-checkbox--round": this.round
      };
    }
  },
  methods: {
    onInput() {
      this.isChecked = !this.isChecked;
      this.$emit("update:modelValue", this.isChecked);
      this.$emit("input", this.isChecked);
      if (!this.noRipple) {
        if (this.isChecked) {
          this.ripple.start = true;
          this.ripple.timeout = setTimeout(() => {
            this.ripple.start = false;
            this.ripple.end = true;
            setTimeout(() => this.ripple.end = false, 100);
          }, 700);
        } else {
          this.ripple.start = false;
          clearTimeout(this.ripple.timeout);
        }
      }
    }
  },
  watch: {
    modelValue(value) {
      this.isChecked = value;
    }
  }
};
var wCheckbox = /* @__PURE__ */ _export_sfc(_sfc_main$H, [["render", render$H]]);
const _hoisted_1$l = ["innerHTML"];
function render$G(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_w_checkbox = resolveComponent("w-checkbox");
  return openBlock(), createBlock(resolveDynamicComponent(_ctx.formRegister ? "w-form-element" : "div"), mergeProps({ ref: "formEl" }, _ctx.formRegister && { validators: _ctx.validators, inputValue: $options.checkboxItems.some((item) => item._isChecked), disabled: _ctx.isDisabled }, {
    valid: _ctx.valid,
    "onUpdate:valid": _cache[1] || (_cache[1] = ($event) => _ctx.valid = $event),
    onReset: $options.reset,
    column: !$props.inline,
    wrap: $props.inline,
    class: $options.classes
  }), {
    default: withCtx(() => [
      (openBlock(true), createElementBlock(Fragment, null, renderList($options.checkboxItems, (item, i) => {
        return openBlock(), createBlock(_component_w_checkbox, mergeProps({
          key: i,
          "model-value": item._isChecked,
          "onUpdate:modelValue": ($event) => $options.toggleCheck(item, $event),
          onFocus: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("focus", $event)),
          name: `${_ctx.inputName}[]`
        }, { label: item.label, color: item.color, labelOnLeft: $props.labelOnLeft, labelColor: $props.labelColor, round: $props.round }, {
          disabled: _ctx.isDisabled || null,
          readonly: _ctx.isReadonly || null,
          class: { mt1: !$props.inline && i }
        }), {
          default: withCtx(() => [
            _ctx.$slots[`item.${i + 1}`] || _ctx.$slots.item ? renderSlot(_ctx.$slots, _ctx.$slots[`item.${i + 1}`] ? `item.${i + 1}` : "item", {
              key: 0,
              item: $options.getOriginalItem(item),
              checked: !!item._isChecked,
              index: i + 1,
              innerHTML: item.label
            }) : item.label ? (openBlock(), createElementBlock("div", {
              key: 1,
              innerHTML: item.label
            }, null, 8, _hoisted_1$l)) : createCommentVNode("", true)
          ]),
          _: 2
        }, 1040, ["model-value", "onUpdate:modelValue", "name", "disabled", "readonly", "class"]);
      }), 128))
    ]),
    _: 3
  }, 16, ["valid", "onReset", "column", "wrap", "class"]);
}
var wCheckboxes_vue_vue_type_style_index_0_lang = "";
const _sfc_main$G = {
  name: "w-checkboxes",
  mixins: [FormElementMixin],
  props: {
    items: { type: Array, required: true },
    modelValue: { type: Array },
    labelOnLeft: { type: Boolean },
    itemLabelKey: { type: String, default: "label" },
    itemValueKey: { type: String, default: "value" },
    itemColorKey: { type: String, default: "color" },
    inline: { type: Boolean },
    round: { type: Boolean },
    color: { type: String, default: "primary" },
    labelColor: { type: String, default: "primary" }
  },
  emits: ["input", "update:modelValue", "focus"],
  provide() {
    return { wCheckboxes: true };
  },
  computed: {
    checkboxItems() {
      return (this.items || []).map((item, i) => {
        const itemValue = item[this.itemValueKey] === void 0 ? item[this.itemLabelKey] || i : item[this.itemValueKey];
        return reactive({
          ...item,
          label: item[this.itemLabelKey],
          _index: i,
          value: itemValue,
          color: item[this.itemColorKey] || this.color,
          _isChecked: this.modelValue && this.modelValue.includes(itemValue)
        });
      });
    },
    classes() {
      return [
        "w-checkboxes",
        `w-checkboxes--${this.inline ? "inline" : "column"}`
      ];
    }
  },
  methods: {
    reset() {
      this.checkboxItems.forEach((item) => item._isChecked = null);
      this.$emit("update:modelValue", []);
      this.$emit("input", []);
    },
    toggleCheck(checkbox, isChecked) {
      checkbox._isChecked = isChecked;
      const selection = this.checkboxItems.filter((item) => item._isChecked).map((item) => item.value);
      this.$emit("update:modelValue", selection);
      this.$emit("input", selection);
    },
    getOriginalItem(item) {
      return this.items[item._index];
    }
  }
};
var wCheckboxes = /* @__PURE__ */ _export_sfc(_sfc_main$G, [["render", render$G]]);
const _hoisted_1$k = { class: "w-confirm" };
function render$F(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_w_button = resolveComponent("w-button");
  const _component_w_flex = resolveComponent("w-flex");
  const _component_w_menu = resolveComponent("w-menu");
  return openBlock(), createElementBlock("div", _hoisted_1$k, [
    createVNode(_component_w_menu, mergeProps({
      modelValue: _ctx.showPopup,
      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.showPopup = $event)
    }, $options.wMenuProps), {
      activator: withCtx(({ on }) => [
        createVNode(_component_w_button, mergeProps({ class: "w-confirm__button" }, { ..._ctx.$attrs, ...$options.buttonProps, ...on }), {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "default")
          ]),
          _: 2
        }, 1040)
      ]),
      default: withCtx(() => [
        createVNode(_component_w_flex, {
          column: !$props.inline,
          "align-center": ""
        }, {
          default: withCtx(() => [
            createElementVNode("div", null, [
              renderSlot(_ctx.$slots, "question", {}, () => [
                createTextVNode(toDisplayString($props.question), 1)
              ])
            ]),
            createElementVNode("div", {
              class: normalizeClass(["w-flex justify-end", $props.inline ? "ml2" : "mt2"])
            }, [
              $props.cancel !== false ? (openBlock(), createBlock(_component_w_button, mergeProps({
                key: 0,
                class: "mr2"
              }, $options.cancelButtonProps, {
                "bg-color": ($options.cancelButton || {}).bgColor || "error",
                onClick: $options.onCancel
              }), {
                default: withCtx(() => [
                  renderSlot(_ctx.$slots, "cancel", {}, () => [
                    createTextVNode(toDisplayString($options.cancelButton.label), 1)
                  ])
                ]),
                _: 3
              }, 16, ["bg-color", "onClick"])) : createCommentVNode("", true),
              createVNode(_component_w_button, mergeProps($options.confirmButtonProps, {
                "bg-color": ($options.confirmButton || {}).bgColor || "success",
                onClick: $options.onConfirm
              }), {
                default: withCtx(() => [
                  renderSlot(_ctx.$slots, "confirm", {}, () => [
                    createTextVNode(toDisplayString($options.confirmButton.label), 1)
                  ])
                ]),
                _: 3
              }, 16, ["bg-color", "onClick"])
            ], 2)
          ]),
          _: 3
        }, 8, ["column"])
      ]),
      _: 3
    }, 16, ["modelValue"])
  ]);
}
const _sfc_main$F = {
  name: "w-confirm",
  props: {
    bgColor: { type: String },
    color: { type: String },
    icon: { type: String },
    mainButton: { type: Object },
    question: { type: String, default: "Are you sure?" },
    cancel: { type: [Boolean, Object, String], default: void 0 },
    confirm: { type: [Object, String] },
    inline: { type: Boolean },
    menu: { type: Object },
    noArrow: { type: Boolean },
    top: { type: Boolean },
    bottom: { type: Boolean },
    left: { type: Boolean },
    right: { type: Boolean },
    alignTop: { type: Boolean },
    alignBottom: { type: Boolean },
    alignLeft: { type: Boolean },
    alignRight: { type: Boolean },
    persistent: { type: Boolean },
    transition: { type: String }
  },
  emits: ["cancel", "confirm"],
  data: () => ({
    showPopup: false,
    props: []
  }),
  computed: {
    cancelButton() {
      let button = { label: typeof this.cancel === "string" ? this.cancel : "Cancel" };
      if (typeof this.cancel === "object")
        button = Object.assign({}, button, this.cancel);
      return button;
    },
    cancelButtonProps() {
      const { label, ...props } = this.cancelButton;
      return props;
    },
    confirmButton() {
      let button = { label: typeof this.confirm === "string" ? this.confirm : "Confirm" };
      if (typeof this.confirm === "object")
        button = Object.assign({}, button, this.confirm);
      return button;
    },
    confirmButtonProps() {
      const { label, ...props } = this.confirmButton;
      return props;
    },
    wMenuProps() {
      return {
        top: this.top,
        bottom: this.bottom,
        left: this.left,
        right: this.right,
        arrow: !this.noArrow,
        alignTop: this.alignTop,
        alignBottom: this.alignBottom,
        alignLeft: this.alignLeft,
        alignRight: this.alignRight,
        persistent: this.persistent,
        transition: this.transition,
        ...this.menu
      };
    },
    buttonProps() {
      return {
        bgColor: this.bgColor,
        color: this.color,
        icon: this.icon,
        ...this.mainButton
      };
    }
  },
  methods: {
    onCancel() {
      this.$emit("cancel");
      this.showPopup = false;
    },
    onConfirm() {
      this.$emit("confirm");
      this.showPopup = false;
    }
  }
};
var wConfirm = /* @__PURE__ */ _export_sfc(_sfc_main$F, [["render", render$F]]);
function render$E(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["w-date-picker", $options.classes]),
    style: normalizeStyle($options.styles)
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 6);
}
var wDatePicker_vue_vue_type_style_index_0_lang = "";
const _sfc_main$E = {
  name: "w-date-picker",
  props: {},
  emits: [],
  computed: {
    classes() {
      return {};
    },
    styles() {
      return false;
    }
  }
};
var wDatePicker = /* @__PURE__ */ _export_sfc(_sfc_main$E, [["render", render$E]]);
function render$D(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_w_card = resolveComponent("w-card");
  const _component_w_overlay = resolveComponent("w-overlay");
  return openBlock(), createBlock(_component_w_overlay, {
    class: normalizeClass(["w-dialog", $options.classes]),
    "model-value": $data.showWrapper,
    persistent: $props.persistent,
    "persistent-no-animation": $props.persistentNoAnimation,
    onClick: $options.onOutsideClick,
    onClose: $options.onClose,
    "bg-color": $props.overlayColor,
    opacity: $props.overlayOpacity
  }, {
    default: withCtx(() => [
      createVNode(Transition, {
        name: $props.transition,
        appear: "",
        onAfterLeave: $options.onBeforeClose
      }, {
        default: withCtx(() => [
          withDirectives(createVNode(_component_w_card, {
            class: normalizeClass(["w-dialog__content", $props.dialogClass]),
            ref: "dialog",
            "no-border": "",
            color: $props.color,
            "bg-color": $props.bgColor,
            "title-class": $props.titleClass,
            "content-class": $props.contentClass,
            title: $props.title || void 0,
            style: normalizeStyle($options.contentStyles)
          }, createSlots({
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "default")
            ]),
            _: 2
          }, [
            _ctx.$slots.title ? {
              name: "title",
              fn: withCtx(() => [
                renderSlot(_ctx.$slots, "title")
              ]),
              key: "0"
            } : void 0,
            _ctx.$slots.actions ? {
              name: "actions",
              fn: withCtx(() => [
                renderSlot(_ctx.$slots, "actions")
              ]),
              key: "1"
            } : void 0
          ]), 1032, ["color", "bg-color", "class", "title-class", "content-class", "title", "style"]), [
            [vShow, $data.showContent]
          ])
        ]),
        _: 3
      }, 8, ["name", "onAfterLeave"])
    ]),
    _: 3
  }, 8, ["model-value", "persistent", "persistent-no-animation", "onClick", "onClose", "bg-color", "opacity", "class"]);
}
var wDialog_vue_vue_type_style_index_0_lang = "";
const _sfc_main$D = {
  name: "w-dialog",
  props: {
    modelValue: { default: true },
    width: { type: [Number, String], default: 0 },
    fullscreen: { type: Boolean },
    persistent: { type: Boolean },
    persistentNoAnimation: { type: Boolean },
    tile: { type: Boolean },
    title: { type: String },
    transition: { type: String, default: "fade" },
    titleClass: { type: String },
    contentClass: { type: String },
    dialogClass: { type: String },
    overlayColor: { type: String },
    color: { type: String },
    bgColor: { type: String },
    overlayOpacity: { type: [Number, String, Boolean] }
  },
  provide() {
    return {
      detachableDefaultRoot: () => this.$refs.dialog.$el || null
    };
  },
  emits: ["input", "update:modelValue", "before-close", "close"],
  data() {
    return {
      showWrapper: this.modelValue,
      showContent: this.modelValue
    };
  },
  computed: {
    maxWidth() {
      let width = this.width;
      if (width && parseInt(width) == width)
        width += "px";
      return width;
    },
    classes() {
      return {
        "w-dialog--fullscreen": this.fullscreen
      };
    },
    contentStyles() {
      return {
        maxWidth: !this.fullscreen && this.maxWidth ? this.maxWidth : null
      };
    }
  },
  methods: {
    onOutsideClick() {
      if (!this.persistent) {
        this.showContent = false;
        if (this.transition === "fade")
          this.onBeforeClose();
      }
    },
    onBeforeClose() {
      this.showWrapper = false;
      this.$emit("before-close");
    },
    onClose() {
      this.$emit("update:modelValue", false);
      this.$emit("input", false);
      this.$emit("close");
    }
  },
  watch: {
    modelValue(value) {
      this.showWrapper = value;
      this.showContent = value;
    }
  }
};
var wDialog = /* @__PURE__ */ _export_sfc(_sfc_main$D, [["render", render$D]]);
const _hoisted_1$j = ["role", "aria-orientation"];
function render$C(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["w-divider", $options.classes]),
    role: _ctx.$slots.default ? null : "presentation",
    "aria-orientation": $props.vertical ? "vertical" : "horizontal"
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 10, _hoisted_1$j);
}
var wDivider_vue_vue_type_style_index_0_lang = "";
const _sfc_main$C = {
  name: "w-divider",
  props: {
    vertical: { type: Boolean },
    color: { type: String }
  },
  emits: [],
  computed: {
    classes() {
      return {
        [`w-divider--has-color ${this.color}`]: this.color,
        [`w-divider--${this.vertical ? "vertical" : "horizontal"}`]: true,
        "w-divider--has-content": this.$slots.default
      };
    }
  }
};
var wDivider = /* @__PURE__ */ _export_sfc(_sfc_main$C, [["render", render$C]]);
const _hoisted_1$i = { class: "w-drawer-wrap__pushable" };
function render$B(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_w_overlay = resolveComponent("w-overlay");
  return $data.showWrapper || $props.pushContent ? (openBlock(), createElementBlock("div", {
    key: 0,
    class: normalizeClass(["w-drawer-wrap", $options.wrapperClasses])
  }, [
    $props.pushContent ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: "w-drawer-wrap__track",
      style: normalizeStyle($options.trackStyles)
    }, [
      createElementVNode("div", _hoisted_1$i, [
        !$props.noOverlay ? (openBlock(), createBlock(_component_w_overlay, {
          key: 0,
          modelValue: $data.showDrawer,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $data.showDrawer = $event),
          onClick: $options.onOutsideClick,
          persistent: $props.persistent,
          "persistent-no-animation": "",
          "bg-color": $props.overlayColor || "transparent",
          opacity: $props.overlayOpacity
        }, null, 8, ["modelValue", "onClick", "persistent", "bg-color", "opacity"])) : createCommentVNode("", true),
        renderSlot(_ctx.$slots, "pushable")
      ]),
      createVNode(Transition, {
        name: "fade",
        onBeforeLeave: $options.onBeforeClose,
        onAfterLeave: $options.onClose
      }, {
        default: withCtx(() => [
          $data.showDrawer ? (openBlock(), createBlock(resolveDynamicComponent($props.tag || "aside"), {
            key: 0,
            class: normalizeClass(["w-drawer", $options.drawerClasses]),
            ref: "drawer",
            style: normalizeStyle($options.styles)
          }, {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "default")
            ]),
            _: 3
          }, 8, ["class", "style"])) : createCommentVNode("", true)
        ]),
        _: 3
      }, 8, ["onBeforeLeave", "onAfterLeave"])
    ], 4)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
      !$props.noOverlay ? (openBlock(), createBlock(_component_w_overlay, {
        key: 0,
        modelValue: $data.showDrawer,
        "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => $data.showDrawer = $event),
        onClick: $options.onOutsideClick,
        persistent: $props.persistent,
        "persistent-no-animation": "",
        "bg-color": $props.overlayColor,
        opacity: $props.overlayOpacity
      }, null, 8, ["modelValue", "onClick", "persistent", "bg-color", "opacity"])) : createCommentVNode("", true),
      createVNode(Transition, {
        name: $options.transitionName,
        appear: "",
        onBeforeLeave: $options.onBeforeClose,
        onAfterLeave: $options.onClose
      }, {
        default: withCtx(() => [
          $data.showDrawer ? (openBlock(), createBlock(resolveDynamicComponent($props.tag || "aside"), {
            key: 0,
            class: normalizeClass(["w-drawer", $options.drawerClasses]),
            ref: "drawer",
            style: normalizeStyle($options.styles)
          }, {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "default")
            ]),
            _: 3
          }, 8, ["class", "style"])) : createCommentVNode("", true)
        ]),
        _: 3
      }, 8, ["name", "onBeforeLeave", "onAfterLeave"])
    ], 64))
  ], 2)) : createCommentVNode("", true);
}
var wDrawer_vue_vue_type_style_index_0_lang = "";
const oppositeSides = { left: "right", right: "left", top: "down", bottom: "up" };
const _sfc_main$B = {
  name: "w-drawer",
  props: {
    modelValue: { default: true },
    left: { type: Boolean },
    right: { type: Boolean },
    top: { type: Boolean },
    bottom: { type: Boolean },
    persistent: { type: Boolean },
    persistentNoAnimation: { type: Boolean },
    fitContent: { type: Boolean },
    width: { type: [Number, String, Boolean] },
    height: { type: [Number, String, Boolean] },
    zIndex: { type: [Number, String, Boolean] },
    color: { type: String },
    bgColor: { type: String },
    noOverlay: { type: Boolean },
    pushContent: { type: Boolean },
    absolute: { type: Boolean },
    overlayColor: { type: String },
    overlayOpacity: { type: [Number, String, Boolean] },
    tag: { type: String, default: "aside" }
  },
  provide() {
    return {
      detachableDefaultRoot: () => this.$refs.drawer || null
    };
  },
  emits: ["input", "update:modelValue", "before-close", "close"],
  data() {
    return {
      showWrapper: this.modelValue,
      showDrawer: this.modelValue,
      persistentAnimate: false
    };
  },
  computed: {
    size() {
      let size = this.width || this.height;
      if (size && parseInt(size) == size)
        size += "px";
      return size || false;
    },
    sizeProperty() {
      return ["left", "right"].includes(this.position) && "width" || "height";
    },
    position() {
      return this.left && "left" || this.right && "right" || this.top && "top" || this.bottom && "bottom" || "right";
    },
    wrapperClasses() {
      return {
        "w-drawer-wrap--fixed": !this.absolute && !this.pushContent,
        "w-drawer-wrap--absolute": this.absolute,
        "w-drawer-wrap--push-content": this.pushContent
      };
    },
    drawerClasses() {
      return {
        [this.color]: this.color,
        [`${this.bgColor}--bg`]: this.bgColor,
        "w-drawer--open": !!this.showDrawer,
        [`w-drawer--${this.position}`]: true,
        "w-drawer--fit-content": this.fitContent,
        "w-drawer--persistent": this.persistent,
        "w-drawer--persistent-animate": this.persistent && this.persistentAnimate
      };
    },
    trackStyles() {
      return this.pushContent && this.showDrawer && {
        transform: `translateX(${this.position === "left" ? "" : "-"}${this.size || "200px"})`
      };
    },
    styles() {
      return {
        [`max-${this.sizeProperty}`]: this.size || null,
        zIndex: this.zIndex || this.zIndex === 0 || null
      };
    },
    unmountDrawer() {
      return !this.showWrapper;
    },
    transitionName() {
      return `slide-${oppositeSides[this.position]}`;
    }
  },
  methods: {
    onBeforeClose() {
      this.$emit("before-close");
    },
    onClose() {
      this.showWrapper = false;
      this.$emit("update:modelValue", false);
      this.$emit("input", false);
      this.$emit("close");
    },
    onOutsideClick() {
      if (!this.persistent) {
        this.showDrawer = false;
      } else if (!this.persistentNoAnimation) {
        this.persistentAnimate = true;
        setTimeout(() => this.persistentAnimate = false, 200);
      }
    }
  },
  watch: {
    modelValue(value) {
      if (value)
        this.showWrapper = true;
      this.showDrawer = value;
    }
  }
};
var wDrawer = /* @__PURE__ */ _export_sfc(_sfc_main$B, [["render", render$B]]);
function render$A(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(resolveDynamicComponent($props.tag), {
    class: normalizeClass(["w-flex", $options.classes])
  }, {
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default")
    ]),
    _: 3
  }, 8, ["class"]);
}
var wFlex_vue_vue_type_style_index_0_lang = "";
const _sfc_main$A = {
  name: "w-flex",
  props: {
    tag: { type: String, default: "div" },
    column: { type: Boolean },
    grow: { type: Boolean },
    noGrow: { type: Boolean },
    shrink: { type: Boolean },
    noShrink: { type: Boolean },
    fillHeight: { type: Boolean },
    wrap: { type: Boolean },
    alignStart: { type: Boolean },
    alignCenter: { type: Boolean },
    alignEnd: { type: Boolean },
    justifyStart: { type: Boolean },
    justifyCenter: { type: Boolean },
    justifyEnd: { type: Boolean },
    justifySpaceBetween: { type: Boolean },
    justifySpaceAround: { type: Boolean },
    justifySpaceEvenly: { type: Boolean },
    basisZero: { type: Boolean },
    gap: { type: [Number, String], default: 0 }
  },
  computed: {
    classes() {
      return {
        column: this.column,
        grow: this.grow,
        "no-grow": this.noGrow,
        shrink: this.shrink,
        "no-shrink": this.noShrink,
        "fill-height": this.fillHeight,
        wrap: this.wrap,
        "align-start": this.alignStart,
        "align-center": this.alignCenter,
        "align-end": this.alignEnd,
        "justify-start": this.justifyStart,
        "justify-center": this.justifyCenter,
        "justify-end": this.justifyEnd,
        "justify-space-between": this.justifySpaceBetween,
        "justify-space-around": this.justifySpaceAround,
        "justify-space-evenly": this.justifySpaceEvenly,
        "basis-zero": this.basisZero,
        [`gap${this.gap}`]: ~~this.gap
      };
    }
  }
};
var wFlex = /* @__PURE__ */ _export_sfc(_sfc_main$A, [["render", render$A]]);
function render$z(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("form", {
    class: normalizeClass(["w-form", $options.classes]),
    onSubmit: _cache[0] || (_cache[0] = (...args) => $options.onSubmit && $options.onSubmit(...args)),
    onReset: _cache[1] || (_cache[1] = (...args) => $options.reset && $options.reset(...args)),
    novalidate: ""
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 34);
}
const asyncSome = async (array, predicate) => {
  for (const item of array) {
    if (await predicate(item))
      return true;
  }
  return false;
};
const _sfc_main$z = {
  name: "w-form",
  props: {
    modelValue: {},
    allowSubmit: { type: Boolean },
    noKeyupValidation: { type: Boolean },
    noBlurValidation: { type: Boolean },
    errorPlaceholders: { type: Boolean },
    validationColor: { type: String, default: "error" },
    disabled: { type: Boolean },
    readonly: { type: Boolean }
  },
  provide() {
    return {
      formRegister: this.register,
      formUnregister: this.unregister,
      validateElement: this.validateElement,
      formProps: this.$props
    };
  },
  emits: [
    "submit",
    "before-validate",
    "validate",
    "success",
    "error",
    "reset",
    "input",
    "update:modelValue",
    "update:errorsCount"
  ],
  data: () => ({
    formElements: [],
    status: null,
    errorsCount: 0
  }),
  computed: {
    classes() {
      return {
        "w-form--pristine": this.status === null,
        "w-form--error": this.status === false,
        "w-form--success": this.status === true,
        "w-form--error-placeholders": this.errorPlaceholders
      };
    }
  },
  methods: {
    register(formElement) {
      this.formElements.push(formElement);
    },
    unregister(formElement) {
      this.formElements = this.formElements.filter((item) => item._.uid !== formElement._.uid);
    },
    async validate(e) {
      this.$emit("before-validate", { e, errorsCount: this.errorsCount });
      let errorsCount = 0;
      await (async () => {
        var _a;
        for (const el of this.formElements) {
          if (!((_a = el.validators) == null ? void 0 : _a.length) || el.disabled || el.readonly)
            continue;
          await this.checkElementValidators(el);
          errorsCount += ~~!el.Validation.isValid;
          el.$emit("update:valid", el.Validation.isValid);
        }
      })();
      this.updateErrorsCount(errorsCount);
      this.status = !errorsCount;
      this.$emit("validate", { e, errorsCount });
      this.$emit(this.status ? "success" : "error", { e, errorsCount });
      return this.status;
    },
    async validateElement(el) {
      await this.checkElementValidators(el);
      this.updateErrorsCount();
      return el.Validation.isValid;
    },
    async checkElementValidators(el) {
      let validationsPassed = false;
      let validationMessage = "";
      await asyncSome(el.validators, async (validator) => {
        const result = await (typeof validator === "function" && validator(el.inputValue));
        validationsPassed = typeof result !== "string";
        validationMessage = validationsPassed ? "" : result;
        return !validationsPassed;
      });
      el.hasJustReset = false;
      el.Validation.isValid = validationsPassed;
      el.Validation.message = validationMessage;
    },
    reset(e) {
      this.status = null;
      this.formElements.forEach((item) => item.reset());
      this.updateErrorsCount(0, true);
      this.$emit("reset", e);
    },
    updateErrorsCount(count = null, reset = false) {
      this.errorsCount = count !== null ? count : this.formElements.reduce((sum, el) => sum + ~~(el.Validation.isValid === false), 0);
      this.status = reset ? null : !this.errorsCount;
      this.$emit("update:modelValue", this.status);
      this.$emit("input", this.status);
      this.$emit("update:errorsCount", this.errorsCount);
    },
    onSubmit(e) {
      this.validate(e);
      this.$emit("submit", e);
      if (!this.allowSubmit || !this.status)
        e.preventDefault();
    }
  },
  created() {
    this.status = this.modelValue || null;
  },
  watch: {
    modelValue(value) {
      if (this.status === false && value || value === null && this.status !== null)
        this.reset();
      this.status = value;
    }
  }
};
var wForm = /* @__PURE__ */ _export_sfc(_sfc_main$z, [["render", render$z]]);
function render$y(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_w_transition_expand = resolveComponent("w-transition-expand");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass($options.classes)
  }, [
    createElementVNode("div", {
      class: normalizeClass(["w-flex grow", [$props.column ? "column" : "align-center", $props.wrap ? "wrap" : ""]])
    }, [
      renderSlot(_ctx.$slots, "default")
    ], 2),
    createVNode(_component_w_transition_expand, { y: "" }, {
      default: withCtx(() => [
        _ctx.Validation.message ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass(["w-form-el__error", $options.formProps.validationColor])
        }, [
          renderSlot(_ctx.$slots, "error-message", {
            message: _ctx.Validation.message
          }, () => [
            createTextVNode(toDisplayString(_ctx.Validation.message), 1)
          ])
        ], 2)) : createCommentVNode("", true)
      ]),
      _: 3
    })
  ], 2);
}
var wFormElement_vue_vue_type_style_index_0_lang = "";
const _sfc_main$y = {
  name: "w-form-element",
  props: {
    valid: { required: true },
    disabled: { type: Boolean },
    readonly: { type: Boolean },
    inputValue: { required: true },
    validators: { type: Array },
    isFocused: { default: false },
    column: { default: false },
    wrap: { default: false }
  },
  inject: {
    formRegister: { default: null },
    formUnregister: { default: null },
    validateElement: { default: null },
    formProps: {
      default: () => ({
        noKeyupValidation: false,
        noBlurValidation: false,
        validationColor: "error",
        disabled: false,
        readonly: false
      })
    }
  },
  emits: ["reset", "update:valid"],
  data: () => ({
    Validation: {
      isValid: null,
      message: ""
    },
    hasJustReset: false
  }),
  computed: {
    classes() {
      const classes = ["w-form-el--error error", "w-form-el--success", "w-form-el--pristine"];
      return [
        "w-form-el",
        classes[this.Validation.isValid === null ? 2 : ~~this.Validation.isValid]
      ];
    }
  },
  methods: {
    reset() {
      this.$emit("reset");
      this.$emit("update:valid", null);
      this.Validation.message = "";
      this.Validation.isValid = null;
      this.hasJustReset = true;
    },
    async validate() {
      this.$emit("update:valid", await this.validateElement(this));
    }
  },
  watch: {
    async inputValue() {
      if (this.hasJustReset)
        return this.hasJustReset = false;
      if (!this.formProps.noKeyupValidation && this.validators) {
        this.$emit("update:valid", await this.validateElement(this));
      }
    },
    async isFocused(val) {
      if (val)
        this.hasJustReset = false;
      else if (!this.formProps.noBlurValidation && this.validators && !this.readonly) {
        this.$emit("update:valid", await this.validateElement(this));
      }
    }
  },
  created() {
    if (this.formRegister)
      this.formRegister(this);
  },
  beforeUnmount() {
    if (this.formUnregister)
      this.formUnregister(this);
  }
};
var wFormElement = /* @__PURE__ */ _export_sfc(_sfc_main$y, [["render", render$y]]);
function render$x(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(resolveDynamicComponent($props.tag), {
    class: normalizeClass(["w-grid", $options.classes])
  }, {
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default")
    ]),
    _: 3
  }, 8, ["class"]);
}
var wGrid_vue_vue_type_style_index_0_lang = "";
const _sfc_main$x = {
  name: "w-grid",
  props: {
    tag: { type: String, default: "div" },
    columns: { type: [Number, Object, String] },
    gap: { type: [Number, Object, String], default: 0 }
  },
  computed: {
    breakpointsColumns() {
      let columns = { xs: 0, sm: 0, md: 0, lg: 0, xl: 0 };
      switch (typeof this.columns) {
        case "object":
          columns = Object.assign(columns, this.columns);
          break;
        case "number":
        case "string":
          columns = Object.keys(columns).reduce((obj, breakpoint) => obj[breakpoint] = ~~this.columns, {});
          break;
      }
      return columns;
    },
    breakpointsGap() {
      let gap = { xs: 0, sm: 0, md: 0, lg: 0, xl: 0 };
      switch (typeof this.gap) {
        case "object":
          gap = Object.assign(gap, this.gap);
          break;
        case "number":
        case "string":
          gap = Object.keys(gap).reduce((obj, breakpoint) => obj[breakpoint] = ~~this.gap, {});
          break;
      }
      return gap;
    },
    classes() {
      let breakpointsColumns = null;
      if (typeof this.columns === "object") {
        breakpointsColumns = Object.entries(this.breakpointsColumns).reduce((obj, [breakpoint, columns]) => {
          obj[`${breakpoint}-columns${columns}`] = true;
          return obj;
        }, {});
      }
      let breakpointsGap = null;
      if (typeof this.gap === "object") {
        breakpointsGap = Object.entries(this.breakpointsGap).reduce((obj, [breakpoint, gap]) => {
          obj[`${breakpoint}-gap${gap}`] = true;
          return obj;
        }, {});
      }
      return {
        ...breakpointsColumns || { [`columns${this.columns}`]: this.columns },
        ...breakpointsGap || { [`gap${this.gap}`]: this.gap }
      };
    }
  }
};
var wGrid = /* @__PURE__ */ _export_sfc(_sfc_main$x, [["render", render$x]]);
function render$w(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(resolveDynamicComponent($props.tag || "i"), mergeProps({ class: "w-icon" }, toHandlers(_ctx.$attrs), {
    class: $options.classes,
    role: "icon",
    "aria-hidden": "true",
    style: $options.readIcon() && $options.styles
  }), {
    default: withCtx(() => [
      $options.hasLigature ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
        createTextVNode(toDisplayString(_ctx.icon), 1)
      ], 64)) : createCommentVNode("", true)
    ]),
    _: 1
  }, 16, ["class", "style"]);
}
var wIcon_vue_vue_type_style_index_0_lang = "";
const _sfc_main$w = {
  name: "w-icon",
  props: {
    tag: { type: String, default: "i" },
    color: { type: String },
    bgColor: { type: String },
    xs: { type: Boolean },
    sm: { type: Boolean },
    md: { type: Boolean },
    lg: { type: Boolean },
    xl: { type: Boolean },
    spin: { type: Boolean },
    spinA: { type: Boolean },
    rotate135a: { type: Boolean },
    rotate90a: { type: Boolean },
    rotate45a: { type: Boolean },
    rotate45: { type: Boolean },
    rotate90: { type: Boolean },
    rotate135: { type: Boolean },
    rotate180: { type: Boolean },
    flipX: { type: Boolean },
    flipY: { type: Boolean },
    size: { type: [Number, String] }
  },
  emits: [],
  data: () => ({
    icon: "",
    fontName: ""
  }),
  computed: {
    hasLigature() {
      return this.$waveui.config.iconsLigature === this.fontName;
    },
    forcedSize() {
      return this.size && (!isNaN(this.size) ? `${this.size}px` : this.size);
    },
    presetSize() {
      return this.xs && "xs" || this.sm && "sm" || this.md && "md" || this.lg && "lg" || this.xl && "xl" || null;
    },
    classes() {
      return {
        [this.fontName]: true,
        [!this.hasLigature && this.icon]: !this.hasLigature && this.icon,
        [this.color]: this.color,
        [`${this.bgColor}--bg`]: this.bgColor,
        [`size--${this.presetSize}`]: this.presetSize && !this.forcedSize,
        "w-icon--spin": this.spin,
        "w-icon--spin-a": this.spinA,
        "w-icon--rotate45": this.rotate45,
        "w-icon--rotate90": this.rotate90,
        "w-icon--rotate135": this.rotate135,
        "w-icon--rotate180": this.rotate180,
        "w-icon--rotate-45": this.rotate45a,
        "w-icon--rotate-90": this.rotate90a,
        "w-icon--rotate-135": this.rotate135a,
        "w-icon--flip-x": this.flipX,
        "w-icon--flip-y": this.flipY
      };
    },
    styles() {
      return this.forcedSize && `font-size: ${this.forcedSize}`;
    }
  },
  methods: {
    readIcon() {
      const { default: slot } = this.$slots;
      const [fontName = "", icon = ""] = typeof slot === "function" && slot()[0].children.trim().split(" ") || [];
      this.fontName = fontName;
      this.icon = icon;
      return true;
    }
  }
};
var wIcon = /* @__PURE__ */ _export_sfc(_sfc_main$w, [["render", render$w]]);
const consoleWarn = (message) => console.warn(`Wave UI: ${message}`);
const consoleError = (message) => console.error(`Wave UI: ${message}`);
const _hoisted_1$h = {
  key: 0,
  class: "w-image__loader"
};
function render$v(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_w_progress = resolveComponent("w-progress");
  return openBlock(), createBlock(resolveDynamicComponent($options.wrapperTag), {
    class: normalizeClass(["w-image-wrap", $options.wrapperClasses]),
    style: normalizeStyle($options.wrapperStyles)
  }, {
    default: withCtx(() => [
      createVNode(Transition, {
        name: $props.transition,
        appear: ""
      }, {
        default: withCtx(() => [
          $data.loaded ? (openBlock(), createBlock(resolveDynamicComponent($props.tag), {
            key: 0,
            class: normalizeClass(["w-image", $options.imageClasses]),
            style: normalizeStyle($options.imageStyles),
            src: $props.tag === "img" ? $data.imgSrc : null
          }, null, 8, ["class", "style", "src"])) : createCommentVNode("", true)
        ]),
        _: 1
      }, 8, ["name"]),
      !$props.noSpinner && $data.loading ? (openBlock(), createElementBlock("div", _hoisted_1$h, [
        _ctx.$slots.loading ? renderSlot(_ctx.$slots, "loading", { key: 0 }) : (openBlock(), createBlock(_component_w_progress, {
          key: 1,
          circle: "",
          indeterminate: ""
        }))
      ])) : createCommentVNode("", true),
      _ctx.$slots.default ? (openBlock(), createBlock(resolveDynamicComponent($options.wrapperTag), {
        key: 1,
        class: normalizeClass(["w-image__content", $props.contentClass])
      }, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 8, ["class"])) : createCommentVNode("", true)
    ]),
    _: 3
  }, 8, ["class", "style"]);
}
var wImage_vue_vue_type_style_index_0_lang = "";
const _sfc_main$v = {
  name: "w-image",
  props: {
    tag: { type: String, default: "span" },
    src: { type: String },
    width: { type: [Number, String] },
    height: { type: [Number, String] },
    ratio: { type: [Number, String] },
    lazy: { type: Boolean },
    absolute: { type: Boolean },
    fixed: { type: Boolean },
    contain: { type: Boolean },
    noSpinner: { type: Boolean },
    fallback: { type: String },
    transition: { type: String, default: "fade" },
    contentClass: { type: [String, Array, Object] }
  },
  emits: ["loading", "loaded", "error"],
  data() {
    return {
      loading: false,
      loaded: false,
      imgSrc: "",
      imgWidth: this.width || 0,
      imgHeight: this.height || 0,
      imgComputedRatio: 0
    };
  },
  computed: {
    imgGivenRatio() {
      return parseFloat(this.ratio);
    },
    wrapperTag() {
      return ["span", "div"].includes(this.tag) ? this.tag : "span";
    },
    wrapperClasses() {
      return {
        "w-image-wrap--absolute": this.absolute,
        "w-image-wrap--fixed": this.fixed,
        "w-image-wrap--has-ratio": this.imgGivenRatio
      };
    },
    wrapperStyles() {
      return {
        width: this.imgGivenRatio ? null : (!isNaN(this.imgWidth) ? `${this.imgWidth}px` : this.imgWidth) || null,
        height: this.imgGivenRatio || this.tag === "img" ? null : (!isNaN(this.imgHeight) ? `${this.imgHeight}px` : this.imgHeight) || null,
        "padding-bottom": this.imgGivenRatio && `${this.imgGivenRatio * 100}%`
      };
    },
    imageClasses() {
      return {
        "w-image--loading": this.loading,
        "w-image--loaded": this.loaded,
        "w-image--contain": this.contain
      };
    },
    imageStyles() {
      return {
        "background-image": this.tag !== "img" && this.loaded ? `url('${this.imgSrc}')` : null
      };
    }
  },
  methods: {
    loadImage(loadFallback = false) {
      if (this.loading)
        return;
      this.loading = true;
      this.loaded = false;
      this.$emit("loading", loadFallback ? this.fallback : this.src);
      return new Promise((resolve) => {
        const img = new Image();
        img.onload = (e) => {
          if (!this.width && !this.height && !this.imgGivenRatio) {
            this.imgWidth = e.target.width;
            this.imgHeight = e.target.height;
          }
          this.imgComputedRatio = e.target.height / e.target.width;
          this.loading = false;
          this.loaded = true;
          this.imgSrc = loadFallback ? this.fallback : this.src;
          this.$emit("loaded", this.imgSrc);
          return resolve(img);
        };
        img.onerror = (error) => {
          this.$emit("error", error);
          if (this.fallback && !loadFallback) {
            this.loading = false;
            this.loadImage(true);
          } else {
            this.loading = false;
            this.loaded = false;
          }
        };
        img.src = loadFallback ? this.fallback : this.src;
      });
    }
  },
  mounted() {
    if (!this.src)
      return consoleWarn("The w-image component was used without src.");
    if (this.lazy) {
      const IntersectObserver = new IntersectionObserver((entry) => {
        if (entry[0] && entry[0].isIntersecting) {
          this.loadImage();
          IntersectObserver.disconnect();
        }
      }, this.intersectionConfig);
      IntersectObserver.observe(this.$el);
    } else
      this.loadImage();
  },
  watch: {
    src() {
      this.loadImage();
    },
    width(value) {
      this.imgWidth = value;
    },
    height(value) {
      this.imgHeight = value;
    }
  }
};
var wImage = /* @__PURE__ */ _export_sfc(_sfc_main$v, [["render", render$v]]);
const _hoisted_1$g = ["name"];
const _hoisted_2$a = ["for"];
const _hoisted_3$9 = ["id", "type", "name", "placeholder", "step", "min", "max", "minlength", "maxlength", "readonly", "aria-readonly", "disabled", "required", "tabindex"];
const _hoisted_4$7 = ["id", "name", "multiple", "data-progress"];
const _hoisted_5$5 = {
  class: "w-input__no-file",
  key: "no-file"
};
const _hoisted_6$3 = /* @__PURE__ */ createTextVNode("No file");
const _hoisted_7$3 = ["for"];
const _hoisted_8$2 = ["for"];
const _hoisted_9$2 = ["src"];
const _hoisted_10$2 = ["for"];
function render$u(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_w_icon = resolveComponent("w-icon");
  const _component_w_progress = resolveComponent("w-progress");
  return openBlock(), createBlock(resolveDynamicComponent(_ctx.formRegister ? "w-form-element" : "div"), mergeProps({ ref: "formEl" }, _ctx.formRegister && { validators: _ctx.validators, inputValue: $data.inputValue, disabled: _ctx.isDisabled, readonly: _ctx.isReadonly, isFocused: $data.isFocused }, {
    valid: _ctx.valid,
    "onUpdate:valid": _cache[10] || (_cache[10] = ($event) => _ctx.valid = $event),
    onReset: _cache[11] || (_cache[11] = ($event) => {
      _ctx.$emit("update:modelValue", $data.inputValue = "");
      _ctx.$emit("input", "");
    }),
    wrap: $options.hasLabel && $props.labelPosition !== "inside",
    class: $options.classes
  }), {
    default: withCtx(() => [
      $props.type === "hidden" ? withDirectives((openBlock(), createElementBlock("input", {
        key: 0,
        type: "hidden",
        name: _ctx.name || null,
        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $data.inputValue = $event)
      }, null, 8, _hoisted_1$g)), [
        [vModelText, $data.inputValue]
      ]) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
        $props.labelPosition === "left" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
          _ctx.$slots.default || $props.label ? (openBlock(), createElementBlock("label", {
            key: 0,
            class: normalizeClass(["w-input__label w-input__label--left w-form-el-shakable", _ctx.labelClasses]),
            for: `w-input--${_ctx._.uid}`
          }, [
            renderSlot(_ctx.$slots, "default", {}, () => [
              createTextVNode(toDisplayString($props.label), 1)
            ])
          ], 10, _hoisted_2$a)) : createCommentVNode("", true)
        ], 64)) : createCommentVNode("", true),
        createElementVNode("div", {
          class: normalizeClass(["w-input__input-wrap", $options.inputWrapClasses])
        }, [
          $props.innerIconLeft ? (openBlock(), createBlock(_component_w_icon, {
            key: 0,
            class: "w-input__icon w-input__icon--inner-left",
            tag: "label",
            for: `w-input--${_ctx._.uid}`,
            onClick: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("click:inner-icon-left", $event))
          }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString($props.innerIconLeft), 1)
            ]),
            _: 1
          }, 8, ["for"])) : createCommentVNode("", true),
          $props.type !== "file" ? withDirectives((openBlock(), createElementBlock("input", mergeProps({
            key: 1,
            class: "w-input__input",
            ref: "input",
            "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => $data.inputValue = $event)
          }, toHandlers($options.listeners, true), {
            onInput: _cache[3] || (_cache[3] = (...args) => $options.onInput && $options.onInput(...args)),
            onFocus: _cache[4] || (_cache[4] = (...args) => $options.onFocus && $options.onFocus(...args)),
            onBlur: _cache[5] || (_cache[5] = (...args) => $options.onBlur && $options.onBlur(...args)),
            id: `w-input--${_ctx._.uid}`,
            type: $props.type,
            name: _ctx.inputName,
            placeholder: $props.placeholder || null,
            step: $props.step || null,
            min: $props.min || null,
            max: $props.max || null,
            minlength: $props.minlength || null,
            maxlength: $props.maxlength || null,
            readonly: _ctx.isReadonly || null,
            "aria-readonly": _ctx.isReadonly ? "true" : "false",
            disabled: _ctx.isDisabled || null,
            required: _ctx.required || null,
            tabindex: _ctx.tabindex || null
          }, $options.attrs), null, 16, _hoisted_3$9)), [
            [vModelDynamic, $data.inputValue]
          ]) : (openBlock(), createElementBlock(Fragment, { key: 2 }, [
            createElementVNode("input", mergeProps({
              ref: "input",
              id: `w-input--${_ctx._.uid}`,
              type: "file",
              name: _ctx.name || null,
              onFocus: _cache[6] || (_cache[6] = (...args) => $options.onFocus && $options.onFocus(...args)),
              onBlur: _cache[7] || (_cache[7] = (...args) => $options.onBlur && $options.onBlur(...args)),
              onChange: _cache[8] || (_cache[8] = (...args) => $options.onFileChange && $options.onFileChange(...args)),
              multiple: $props.multiple || null
            }, $options.attrs, {
              "data-progress": $options.overallFilesProgress
            }), null, 16, _hoisted_4$7),
            createVNode(TransitionGroup, {
              class: "w-input__input w-input__input--file",
              tag: "label",
              name: "fade",
              for: `w-input--${_ctx._.uid}`
            }, {
              default: withCtx(() => [
                !$data.inputFiles.length && $data.isFocused ? (openBlock(), createElementBlock("span", _hoisted_5$5, [
                  renderSlot(_ctx.$slots, "no-file", {}, () => [
                    _ctx.$slots["no-file"] === void 0 ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                      _hoisted_6$3
                    ], 64)) : createCommentVNode("", true)
                  ])
                ])) : createCommentVNode("", true),
                (openBlock(true), createElementBlock(Fragment, null, renderList($data.inputFiles, (file, i) => {
                  return openBlock(), createElementBlock("span", {
                    key: file.lastModified
                  }, [
                    createTextVNode(toDisplayString(i ? ", " : ""), 1),
                    (openBlock(), createElementBlock("span", {
                      class: "filename",
                      key: `${i}b`
                    }, toDisplayString(file.base), 1)),
                    createTextVNode(toDisplayString(file.extension ? `.${file.extension}` : ""), 1)
                  ]);
                }), 128))
              ]),
              _: 3
            }, 8, ["for"])
          ], 64)),
          $props.labelPosition === "inside" && $options.showLabelInside ? (openBlock(), createElementBlock(Fragment, { key: 3 }, [
            _ctx.$slots.default || $props.label ? (openBlock(), createElementBlock("label", {
              key: 0,
              class: normalizeClass(["w-input__label w-input__label--inside w-form-el-shakable", _ctx.labelClasses]),
              for: `w-input--${_ctx._.uid}`
            }, [
              renderSlot(_ctx.$slots, "default", {}, () => [
                createTextVNode(toDisplayString($props.label), 1)
              ])
            ], 10, _hoisted_7$3)) : createCommentVNode("", true)
          ], 64)) : createCommentVNode("", true),
          $props.innerIconRight ? (openBlock(), createBlock(_component_w_icon, {
            key: 4,
            class: "w-input__icon w-input__icon--inner-right",
            tag: "label",
            for: `w-input--${_ctx._.uid}`,
            onClick: _cache[9] || (_cache[9] = ($event) => _ctx.$emit("click:inner-icon-right", $event))
          }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString($props.innerIconRight), 1)
            ]),
            _: 1
          }, 8, ["for"])) : createCommentVNode("", true),
          $options.hasLoading || $props.showProgress && ($options.uploadInProgress || $options.uploadComplete) ? (openBlock(), createBlock(_component_w_progress, {
            key: 5,
            class: "fill-width",
            size: "2",
            color: $props.progressColor || $props.color,
            "model-value": $props.showProgress ? ($options.uploadInProgress || $options.uploadComplete) && $options.overallFilesProgress : $options.loadingValue
          }, null, 8, ["color", "model-value"])) : createCommentVNode("", true)
        ], 2),
        $props.type === "file" && $props.preview && $data.inputFiles.length ? (openBlock(), createElementBlock("label", {
          key: 1,
          class: "d-flex",
          for: `w-input--${_ctx._.uid}`
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList($data.inputFiles, (file, i) => {
            return openBlock(), createElementBlock(Fragment, null, [
              file.progress < 100 ? (openBlock(), createElementBlock("i", {
                class: "w-icon wi-spinner w-icon--spin size--sm w-input__file-preview primary",
                key: `${i}a`
              })) : file.preview ? (openBlock(), createElementBlock("img", {
                class: "w-input__file-preview",
                key: `${i}b`,
                src: file.preview,
                alt: ""
              }, null, 8, _hoisted_9$2)) : (openBlock(), createElementBlock("i", {
                class: normalizeClass(["w-icon w-input__file-preview primary size--md", $props.preview && typeof $props.preview === "string" ? $props.preview : "wi-file"]),
                key: `${i}c`
              }, null, 2))
            ], 64);
          }), 256))
        ], 8, _hoisted_8$2)) : createCommentVNode("", true),
        $props.labelPosition === "right" ? (openBlock(), createElementBlock(Fragment, { key: 2 }, [
          _ctx.$slots.default || $props.label ? (openBlock(), createElementBlock("label", {
            key: 0,
            class: normalizeClass(["w-input__label w-input__label--right w-form-el-shakable", _ctx.labelClasses]),
            for: `w-input--${_ctx._.uid}`
          }, [
            renderSlot(_ctx.$slots, "default", {}, () => [
              createTextVNode(toDisplayString($props.label), 1)
            ])
          ], 10, _hoisted_10$2)) : createCommentVNode("", true)
        ], 64)) : createCommentVNode("", true)
      ], 64))
    ]),
    _: 3
  }, 16, ["valid", "wrap", "class"]);
}
var wInput_vue_vue_type_style_index_0_lang = "";
const _sfc_main$u = {
  name: "w-input",
  mixins: [FormElementMixin],
  props: {
    modelValue: { default: "" },
    type: { type: String, default: "text" },
    label: { type: String },
    labelPosition: { type: String, default: "inside" },
    innerIconLeft: { type: String },
    innerIconRight: { type: String },
    staticLabel: { type: Boolean },
    placeholder: { type: String },
    color: { type: String, default: "primary" },
    bgColor: { type: String },
    labelColor: { type: String, default: "primary" },
    progressColor: { type: String },
    minlength: { type: [Number, String] },
    maxlength: { type: [Number, String] },
    step: { type: [Number, String] },
    min: { type: [Number, String] },
    max: { type: [Number, String] },
    dark: { type: Boolean },
    outline: { type: Boolean },
    round: { type: Boolean },
    shadow: { type: Boolean },
    tile: { type: Boolean },
    multiple: { type: Boolean },
    preview: { type: [Boolean, String], default: true },
    loading: { type: [Boolean, Number], default: false },
    showProgress: { type: [Boolean] },
    files: { type: Array }
  },
  emits: ["input", "update:modelValue", "focus", "blur", "click:inner-icon-left", "click:inner-icon-right", "update:overallProgress"],
  data() {
    return {
      inputValue: this.modelValue,
      inputNumberError: false,
      isFocused: false,
      inputFiles: [],
      fileReader: null,
      isAutofilled: false
    };
  },
  computed: {
    attrs() {
      const { class: classes, ...attrs } = this.$attrs;
      return attrs;
    },
    listeners() {
      const { input, focus, blur, ...listeners } = this.$attrs;
      return listeners;
    },
    attrs() {
      const { class: Class, ...htmlAttrs } = this.$attrs;
      return htmlAttrs;
    },
    hasValue() {
      switch (this.type) {
        case "file":
          return !!this.inputFiles.length;
        case "number":
          return this.inputValue || this.inputValue === 0 || this.inputNumberError;
        case "date":
        case "time":
          return true;
        default:
          return this.inputValue || this.inputValue === 0;
      }
    },
    hasLabel() {
      return this.label || this.$slots.default;
    },
    hasLoading() {
      return ![void 0, false].includes(this.loading);
    },
    loadingValue() {
      let value;
      if (typeof this.loading === "number")
        value = this.loading;
      else if (this.loading) {
        value = this.type === "file" && this.overallFilesProgress ? this.overallFilesProgress : void 0;
      }
      return value;
    },
    showLabelInside() {
      return !this.staticLabel || !this.hasValue && !this.placeholder;
    },
    overallFilesProgress() {
      const progress = +this.inputFiles.reduce((total2, file) => total2 + file.progress, 0);
      const total = progress / this.inputFiles.length;
      this.$emit("update:overallProgress", this.inputFiles.length ? total : void 0);
      return total;
    },
    uploadInProgress() {
      return this.overallFilesProgress > 0 && this.overallFilesProgress < 100;
    },
    uploadComplete() {
      return this.overallFilesProgress === 100;
    },
    classes() {
      return {
        "w-input": true,
        "w-input--file": this.type === "file",
        "w-input--disabled": this.isDisabled,
        "w-input--readonly": this.isReadonly,
        [`w-input--${this.hasValue || this.isAutofilled ? "filled" : "empty"}`]: true,
        "w-input--focused": this.isFocused && !this.isReadonly,
        "w-input--dark": this.dark,
        "w-input--floating-label": this.hasLabel && this.labelPosition === "inside" && !this.staticLabel,
        "w-input--no-padding": !this.outline && !this.bgColor && !this.shadow && !this.round,
        "w-input--has-placeholder": this.placeholder,
        "w-input--inner-icon-left": this.innerIconLeft,
        "w-input--inner-icon-right": this.innerIconRight
      };
    },
    inputWrapClasses() {
      return {
        [this.valid === false ? this.validationColor : this.color]: this.color || this.valid === false,
        [`${this.bgColor}--bg`]: this.bgColor,
        "w-input__input-wrap--file": this.type === "file",
        "w-input__input-wrap--round": this.round,
        "w-input__input-wrap--tile": this.tile,
        "w-input__input-wrap--box": this.outline || this.bgColor || this.shadow,
        "w-input__input-wrap--underline": !this.outline,
        "w-input__input-wrap--shadow": this.shadow,
        "w-input__input-wrap--no-padding": !this.outline && !this.bgColor && !this.shadow && !this.round,
        "w-input__input-wrap--loading": this.loading || this.showProgress && this.uploadInProgress,
        "w-input__input-wrap--upload-complete": this.uploadComplete
      };
    }
  },
  methods: {
    onInput(e) {
      this.inputNumberError = e.target.validity.badInput;
      this.$emit("update:modelValue", this.inputValue);
      this.$emit("input", this.inputValue);
    },
    onFocus(e) {
      this.isFocused = true;
      this.$emit("focus", e);
    },
    onBlur(e) {
      this.isFocused = false;
      this.$emit("blur", e);
    },
    onFileChange(e) {
      this.inputFiles = [...e.target.files].map((original) => {
        const [, base = "", extension = "", full = ""] = original.name.match(/^(.*?)\.([^.]*)$|(.*)/);
        const file = reactive({
          name: original.name,
          base: base || full,
          extension,
          type: original.type,
          size: original.size,
          lastModified: original.lastModified,
          preview: null,
          progress: 0,
          file: original
        });
        this.readFile(original, file);
        return file;
      });
      this.$emit("update:modelValue", this.inputFiles);
      this.$emit("input", this.inputFiles);
    },
    readFile(original, file) {
      const reader = new FileReader();
      const isPreviewAnIcon = typeof this.preview === "string";
      const isFileAnImage = original.type && original.type.startsWith("image/");
      if (this.preview && !isPreviewAnIcon && isFileAnImage) {
        reader.addEventListener("load", (e) => {
          file.preview = e.target.result;
        });
      } else
        delete file.preview;
      reader.addEventListener("progress", (e) => {
        if (e.loaded && e.total)
          file.progress = e.loaded * 100 / e.total;
      });
      reader.readAsDataURL(original);
    }
  },
  mounted() {
    setTimeout(() => {
      if (this.$refs.input && this.$refs.input.matches(":-webkit-autofill"))
        this.isAutofilled = true;
    }, 400);
  },
  watch: {
    modelValue(value) {
      this.inputValue = value;
      if (!value && value !== 0)
        this.isAutofilled = false;
    }
  }
};
var wInput = /* @__PURE__ */ _export_sfc(_sfc_main$u, [["render", render$u]]);
function render$t(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_w_icon = resolveComponent("w-icon");
  const _component_w_list = resolveComponent("w-list", true);
  return openBlock(), createElementBlock("ul", {
    class: normalizeClass(["w-list", $options.classes])
  }, [
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.listItems, (li, i) => {
      return openBlock(), createElementBlock("li", {
        class: normalizeClass(["w-list__item", { "w-list__item--parent": (li.children || []).length }]),
        key: i
      }, [
        $props.icon ? (openBlock(), createBlock(_component_w_icon, {
          key: 0,
          class: "w-list__item-bullet"
        }, {
          default: withCtx(() => [
            createTextVNode(toDisplayString($props.icon), 1)
          ]),
          _: 1
        })) : createCommentVNode("", true),
        _ctx.$slots[`item.${i + 1}`] || _ctx.$slots.item || _ctx.$slots.default ? (openBlock(), createBlock(resolveDynamicComponent($props.checklist ? "w-checkbox" : $props.nav && !li.disabled && li.route ? $options.hasRouter ? "router-link" : "a" : "div"), mergeProps({
          key: 1,
          class: "w-list__item-label"
        }, $options.liLabelProps(li, i, li._selected)), {
          default: withCtx(() => [
            _ctx.$slots[`item.${i + 1}`] ? renderSlot(_ctx.$slots, `item.${i + 1}`, {
              key: 0,
              item: $options.cleanLi(li),
              index: i + 1,
              selected: li._selected
            }) : _ctx.$slots.item ? renderSlot(_ctx.$slots, "item", {
              key: 1,
              item: $options.cleanLi(li),
              index: i + 1,
              selected: li._selected
            }) : renderSlot(_ctx.$slots, "default", {
              key: 2,
              item: $options.cleanLi(li),
              index: i + 1,
              selected: li._selected
            }, () => [
              createTextVNode(toDisplayString(li._label), 1)
            ])
          ]),
          _: 2
        }, 1040)) : (openBlock(), createBlock(resolveDynamicComponent($props.checklist ? "w-checkbox" : $props.nav && !li.disabled && li.route ? $options.hasRouter ? "router-link" : "a" : "div"), mergeProps({
          key: 2,
          class: "w-list__item-label"
        }, $options.liLabelProps(li, i, li._selected)), null, 16)),
        (li.children || []).length ? (openBlock(), createBlock(_component_w_list, mergeProps({ key: 3 }, _ctx.$props, {
          items: li.children,
          depth: $props.depth + 1,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:modelValue", $event)),
          onInput: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("input", $event)),
          onItemClick: _cache[2] || (_cache[2] = ($event) => _ctx.$emit("item-click", $event)),
          onItemSelect: _cache[3] || (_cache[3] = ($event) => _ctx.$emit("item-select", $event))
        }), createSlots({ _: 2 }, [
          _ctx.$slots.item ? {
            name: "item",
            fn: withCtx(({ item, index: index2, selected }) => [
              renderSlot(_ctx.$slots, "item", {
                item: $options.cleanLi(item),
                index: index2,
                selected
              })
            ]),
            key: "0"
          } : {
            name: "default",
            fn: withCtx(({ item, index: index2, selected }) => [
              renderSlot(_ctx.$slots, "default", {
                item: $options.cleanLi(item),
                index: index2,
                selected
              }, () => [
                createTextVNode(toDisplayString(item[$props.itemLabelKey]), 1)
              ])
            ]),
            key: "1"
          }
        ]), 1040, ["items", "depth"])) : createCommentVNode("", true)
      ], 2);
    }), 128))
  ], 2);
}
var wList_vue_vue_type_style_index_0_lang = "";
const _sfc_main$t = {
  name: "w-list",
  props: {
    items: { type: [Array, Number], required: true },
    modelValue: {},
    checklist: { type: Boolean },
    roundCheckboxes: { type: Boolean },
    multiple: { type: Boolean },
    addIds: { type: [Boolean, String] },
    hover: { type: Boolean },
    color: { type: String },
    selectionColor: { type: String },
    bgColor: { type: String },
    nav: { type: Boolean },
    icon: { type: String, default: "" },
    itemLabelKey: { type: String, default: "label" },
    itemValueKey: { type: String, default: "value" },
    itemClassKey: { type: String, default: "class" },
    itemColorKey: { type: String, default: "color" },
    itemRouteKey: { type: String, default: "route" },
    itemClass: { type: String },
    depth: { type: Number, default: 0 },
    returnObject: { type: Boolean },
    noUnselect: { type: Boolean },
    arrowsNavigation: { type: Boolean }
  },
  emits: ["input", "update:modelValue", "item-click", "item-select", "keydown:escape", "keydown:enter"],
  data: () => ({
    listItems: []
  }),
  computed: {
    hasRouter() {
      return "$router" in this;
    },
    listId() {
      return this.addIds ? typeof this.addIds === "string" ? this.addIds : `w-list--${this._.uid}` : null;
    },
    selectedItems() {
      return this.listItems.filter((item) => item._selected);
    },
    enabledItemsIndexes() {
      return this.listItems.filter((item) => !item.disabled).map((item) => item.index);
    },
    isMultipleSelect() {
      return this.multiple || this.checklist;
    },
    isSelectable() {
      return this.modelValue !== void 0 || this.checklist || this.nav;
    },
    SelectionColor() {
      const selectionColor = this.selectionColor === void 0 ? !this.color && "primary" : this.selectionColor;
      return this.isSelectable && selectionColor;
    },
    classes() {
      return {
        [this.color]: this.color || null,
        [`${this.bgColor}--bg`]: this.bgColor || null,
        "w-list--checklist": this.checklist,
        "w-list--navigation": this.nav,
        "w-list--icon": this.icon,
        [`w-list--child w-list--depth-${this.depth}`]: this.depth
      };
    }
  },
  methods: {
    getItemValue(item) {
      if (item && typeof item === "object") {
        if (item[this.itemValueKey] !== void 0)
          return item[this.itemValueKey];
        else
          return item[this.itemLabelKey] !== void 0 ? item[this.itemLabelKey] : item.index;
      } else
        return item;
    },
    selectItem(item, forcedValue) {
      if (item._selected && !this.multiple && this.noUnselect)
        return;
      item._selected = forcedValue !== void 0 ? forcedValue : !item._selected;
      if (item._selected && !this.isMultipleSelect) {
        this.listItems.forEach((i) => i._index !== item._index && (i._selected = false));
      }
      this.emitSelection();
    },
    liLabelClasses(item) {
      return {
        "w-list__item-label--disabled": item.disabled || this.nav && !item[this.itemRouteKey] && !item.children,
        "w-list__item-label--active": this.isSelectable && item._selected || null,
        "w-list__item-label--focused": item._focused,
        "w-list__item-label--hoverable": this.hover,
        "w-list__item-label--selectable": this.isSelectable,
        [item.color]: !!item.color,
        [this.SelectionColor]: item._selected && !item.color && this.SelectionColor,
        [item[this.itemClassKey] || this.itemClass]: item[this.itemClassKey] || this.itemClass
      };
    },
    liLabelProps(li, index2, selected) {
      const hasSlot = this.$slots[`item.${index2 + 1}`] || this.$slots.item;
      const click = () => {
        if (!li.disabled) {
          const cleanLi = this.cleanLi(li);
          this.$emit("item-click", cleanLi);
          this.$emit("item-select", cleanLi);
        }
      };
      const mousedown = this.isSelectable && ((e) => {
        e.stopPropagation();
        !li.disabled && this.selectItem(li);
      });
      const keydown = this.isSelectable && ((e) => {
        if (!li.disabled && e.keyCode === 13) {
          this.selectItem(li);
          this.$emit("keydown:enter");
          this.$emit("item-select", this.cleanLi(li));
        } else if (e.keyCode === 27)
          this.$emit("keydown:escape");
        else if (this.arrowsNavigation) {
          e.preventDefault();
          if (e.keyCode === 38)
            this.focusPrevNextItem(li._index, false);
          if (e.keyCode === 40)
            this.focusPrevNextItem(li._index, true);
        }
      });
      const props = {
        class: this.liLabelClasses(li),
        tabindex: li.disabled || this.checklist ? null : "0",
        "aria-selected": selected ? "true" : "false",
        id: this.listId ? `${this.listId}_item-${index2 + 1}` : null,
        role: "option"
      };
      if (this.checklist) {
        props.modelValue = li._selected;
        props.color = li[this.itemColorKey] || this.color;
        props.round = this.roundCheckboxes;
        props.disabled = li.disabled;
        if (!hasSlot)
          props.label = li._label || null;
        props.onFocus = () => li._focused = true;
        props.onBlur = () => li._focused = false;
        props.onInput = (value) => this.selectItem(li, value);
        props.onClick = (e) => {
          const checkbox = e.target.querySelector('input[type="checkbox"]');
          if (checkbox) {
            checkbox.focus();
            checkbox.click();
          }
          click();
        };
      } else if (this.nav) {
        if (!li.disabled && li[this.itemRouteKey]) {
          props.onKeydown = keydown;
          props.onMousedown = mousedown;
          if (this.$router) {
            props.to = li[this.itemRouteKey];
            props.onClick = (e) => {
              e.preventDefault();
              this.$router.push(li[this.itemRouteKey]);
              click();
            };
          } else {
            props.href = li[this.itemRouteKey];
            props.onClick = click;
          }
        }
        if (!hasSlot)
          props.innerHTML = li._label;
      } else if (this.isSelectable) {
        if (!li.disabled)
          props.tabindex = 0;
        props.onClick = click;
        props.onKeydown = keydown;
        props.onMousedown = mousedown;
        if (!hasSlot)
          props.innerHTML = li._label;
      } else if (!hasSlot)
        props.innerHTML = li._label;
      return props;
    },
    checkSelection(items) {
      items = Array.isArray(items) ? items : items ? [items] : [];
      if (this.returnObject)
        items = items.map(this.getItemValue);
      return items;
    },
    emitSelection() {
      const items = this.selectedItems.map((item) => {
        if (!this.returnObject)
          return item._value;
        const { _value, _selected, ...Item } = item;
        return Item;
      });
      const selection = this.isMultipleSelect ? items : items[0] !== void 0 ? items[0] : null;
      this.$emit("update:modelValue", selection);
      this.$emit("input", selection);
    },
    focusPrevNextItem(index2, next = true) {
      index2 = this.enabledItemsIndexes[this.enabledItemsIndexes.indexOf(index2) + (next ? 1 : -1)];
      const firstOrLastIndex = next ? 0 : this.enabledItemsIndexes.length - 1;
      if (index2 === void 0)
        index2 = this.enabledItemsIndexes[firstOrLastIndex];
      this.$el.querySelector(`#${this.listId}_item-${index2 + 1}`).focus();
    },
    cleanLi(li) {
      const { _index, _value, _label, _selected, _focused, ...cleanLi } = li;
      return cleanLi;
    },
    refreshListItems() {
      const items = typeof this.items === "number" ? Array(this.items).fill({}) : this.items || [];
      this.listItems = items.map((item, i) => ({
        ...item,
        _index: i,
        _value: item[this.itemValueKey] === void 0 ? item[this.itemLabelKey] || i : item[this.itemValueKey],
        _selected: item._selected || false,
        _label: item[this.itemLabelKey] || "",
        _focused: false
      }));
    },
    applySelectionOnItems(selection) {
      if (!this.isMultipleSelect)
        this.listItems.forEach((item) => item._selected = false);
      this.checkSelection(selection).forEach((val) => this.listItems.find((item) => item._value === val)._selected = true);
    }
  },
  created() {
    this.refreshListItems();
    this.applySelectionOnItems(this.modelValue);
  },
  watch: {
    items() {
      this.refreshListItems();
      this.applySelectionOnItems(this.modelValue);
    },
    modelValue(items) {
      this.applySelectionOnItems(items);
    },
    multiple(boolean) {
      if (!boolean) {
        let firstSelected = null;
        this.listItems.forEach((item) => {
          if (item._selected && !firstSelected)
            firstSelected = item;
          else if (item._selected)
            item._selected = false;
        });
        this.emitSelection();
      }
    }
  }
};
var wList = /* @__PURE__ */ _export_sfc(_sfc_main$t, [["render", render$t]]);
var DetachableMixin = {
  props: {
    appendTo: { type: [String, Boolean, Object] },
    fixed: { type: Boolean },
    top: { type: Boolean },
    bottom: { type: Boolean },
    left: { type: Boolean },
    right: { type: Boolean },
    alignTop: { type: Boolean },
    alignBottom: { type: Boolean },
    alignLeft: { type: Boolean },
    alignRight: { type: Boolean },
    noPosition: { type: Boolean },
    zIndex: { type: [Number, String, Boolean] },
    activator: { type: [String, Object, HTMLElement] }
  },
  inject: {
    detachableDefaultRoot: { default: null }
  },
  data: () => ({
    docEventListenersHandlers: []
  }),
  computed: {
    appendToTarget() {
      let defaultTarget = ".w-app";
      if (typeof this.detachableDefaultRoot === "function") {
        defaultTarget = this.detachableDefaultRoot() || defaultTarget;
      }
      let target = this.appendTo || defaultTarget;
      if (target === true)
        target = defaultTarget;
      else if (this.appendTo === "activator")
        target = this.$el.previousElementSibling;
      else if (target && !["object", "string"].includes(typeof target))
        target = defaultTarget;
      else if (typeof target === "object" && !target.nodeType) {
        target = defaultTarget;
        consoleWarn(`Invalid node provided in ${this.$options.name} \`append-to\`. Falling back to .w-app.`);
      }
      if (typeof target === "string")
        target = document.querySelector(target);
      if (!target) {
        consoleWarn(`Unable to locate ${this.appendTo ? `target ${this.appendTo}` : defaultTarget}`);
        target = document.querySelector(defaultTarget);
      }
      return target;
    },
    detachableParentEl() {
      return this.appendToTarget;
    },
    hasSeparateActivator() {
      var _a;
      if (this.$slots.activator)
        return false;
      const activatorIsString = typeof this.activator === "string";
      const activatorIsDomEl = (((_a = this.activator) == null ? void 0 : _a.$el) || this.activator) instanceof HTMLElement;
      return activatorIsString || activatorIsDomEl;
    },
    activatorEl: {
      get() {
        var _a;
        if (this.hasSeparateActivator) {
          const activator = ((_a = this.activator) == null ? void 0 : _a.$el) || this.activator;
          if (activator instanceof HTMLElement)
            return activator;
          return document.querySelector(this.activator);
        }
        return this.$el.nextElementSibling;
      },
      set() {
      }
    },
    position() {
      return this.top && "top" || this.bottom && "bottom" || this.left && "left" || this.right && "right" || "bottom";
    },
    alignment() {
      return ["top", "bottom"].includes(this.position) && this.alignLeft && "left" || ["top", "bottom"].includes(this.position) && this.alignRight && "right" || ["left", "right"].includes(this.position) && this.alignTop && "top" || ["left", "right"].includes(this.position) && this.alignBottom && "bottom" || "";
    }
  },
  methods: {
    async open(e) {
      if (this.delay)
        await new Promise((resolve) => setTimeout(resolve, this.delay));
      this.detachableVisible = true;
      if (this.activator)
        this.activatorEl = e.target;
      await this.insertInDOM();
      if (this.minWidth === "activator")
        this.activatorWidth = this.activatorEl.offsetWidth;
      if (!this.noPosition)
        this.computeDetachableCoords();
      this.timeoutId = setTimeout(() => {
        this.$emit("update:modelValue", true);
        this.$emit("input", true);
        this.$emit("open");
      }, 0);
      if (!this.persistent)
        document.addEventListener("mousedown", this.onOutsideMousedown);
      if (!this.noPosition)
        window.addEventListener("resize", this.onResize);
    },
    getActivatorCoordinates() {
      const { top, left, width, height } = this.activatorEl.getBoundingClientRect();
      let coords = { top, left, width, height };
      if (!this.fixed) {
        const { top: targetTop, left: targetLeft } = this.detachableParentEl.getBoundingClientRect();
        const computedStyles = window.getComputedStyle(this.detachableParentEl, null);
        coords = {
          ...coords,
          top: top - targetTop + this.detachableParentEl.scrollTop - parseInt(computedStyles.getPropertyValue("border-top-width")),
          left: left - targetLeft + this.detachableParentEl.scrollLeft - parseInt(computedStyles.getPropertyValue("border-left-width"))
        };
      }
      return coords;
    },
    computeDetachableCoords() {
      let { top, left, width, height } = this.getActivatorCoordinates();
      if (!this.detachableEl)
        return;
      this.detachableEl.style.visibility = "hidden";
      this.detachableEl.style.display = "flex";
      const computedStyles = window.getComputedStyle(this.detachableEl, null);
      switch (this.position) {
        case "top": {
          top -= this.detachableEl.offsetHeight;
          if (this.alignRight) {
            left += width - this.detachableEl.offsetWidth + parseInt(computedStyles.getPropertyValue("border-right-width"));
          } else if (!this.alignLeft)
            left += (width - this.detachableEl.offsetWidth) / 2;
          break;
        }
        case "bottom": {
          top += height;
          if (this.alignRight) {
            left += width - this.detachableEl.offsetWidth + parseInt(computedStyles.getPropertyValue("border-right-width"));
          } else if (!this.alignLeft)
            left += (width - this.detachableEl.offsetWidth) / 2;
          break;
        }
        case "left": {
          left -= this.detachableEl.offsetWidth;
          if (this.alignBottom)
            top += height - this.detachableEl.offsetHeight;
          else if (!this.alignTop)
            top += (height - this.detachableEl.offsetHeight) / 2;
          break;
        }
        case "right": {
          left += width;
          if (this.alignBottom) {
            top += height - this.detachableEl.offsetHeight + parseInt(computedStyles.getPropertyValue("margin-top"));
          } else if (!this.alignTop) {
            top += (height - this.detachableEl.offsetHeight) / 2 + parseInt(computedStyles.getPropertyValue("margin-top"));
          }
          break;
        }
      }
      this.detachableEl.style.visibility = null;
      if (!this.detachableVisible)
        this.detachableEl.style.display = "none";
      this.detachableCoords = { top, left };
    },
    onResize() {
      if (this.minWidth === "activator")
        this.activatorWidth = this.activatorEl.offsetWidth;
      this.computeDetachableCoords();
    },
    onOutsideMousedown(e) {
      if (!this.detachableEl.contains(e.target) && !this.activatorEl.contains(e.target)) {
        this.$emit("update:modelValue", this.detachableVisible = false);
        this.$emit("input", false);
        this.$emit("close");
        document.removeEventListener("mousedown", this.onOutsideMousedown);
        window.removeEventListener("resize", this.onResize);
      }
    },
    insertInDOM() {
      return new Promise((resolve) => {
        this.$nextTick(() => {
          var _a;
          this.detachableEl = ((_a = this.$refs.detachable) == null ? void 0 : _a.$el) || this.$refs.detachable;
          if (this.detachableEl)
            this.appendToTarget.appendChild(this.detachableEl);
          resolve();
        });
      });
    },
    removeFromDOM() {
      document.removeEventListener("mousedown", this.onOutsideMousedown);
      window.removeEventListener("resize", this.onResize);
      if (this.detachableEl && this.detachableEl.parentNode) {
        this.detachableVisible = false;
        this.detachableEl.remove();
        this.detachableEl = null;
      }
    },
    bindActivatorEvents() {
      const activatorIsString = typeof this.activator === "string";
      Object.entries(this.activatorEventHandlers).forEach(([eventName, handler]) => {
        eventName = eventName.replace("mouseenter", "mouseover").replace("mouseleave", "mouseout");
        const handlerWrap = (e) => {
          var _a;
          if (activatorIsString && ((_a = e.target) == null ? void 0 : _a.matches) && e.target.matches(this.activator))
            handler(e);
          else if (e.target === this.activatorEl || this.activatorEl.contains(e.target))
            handler(e);
        };
        document.addEventListener(eventName, handlerWrap);
        this.docEventListenersHandlers.push({ eventName, handler: handlerWrap });
      });
    }
  },
  mounted() {
    var _a;
    if (this.activator)
      this.bindActivatorEvents();
    else {
      this.$nextTick(() => {
        if (this.activator)
          this.bindActivatorEvents();
        if (this.modelValue)
          this.toggle({ type: "click", target: this.activatorEl });
      });
    }
    if (this.overlay)
      this.overlayEl = (_a = this.$refs.overlay) == null ? void 0 : _a.$el;
    if (this.modelValue && this.activator)
      this.toggle({ type: "click", target: this.activatorEl });
  },
  unmounted() {
    this.close();
    this.removeFromDOM();
    if (this.docEventListenersHandlers.length) {
      this.docEventListenersHandlers.forEach(({ eventName, handler }) => {
        document.removeEventListener(eventName, handler);
      });
    }
  },
  watch: {
    modelValue(bool) {
      if (!!bool !== this.detachableVisible)
        this.toggle({ type: "click", target: this.activatorEl });
    },
    appendTo() {
      this.removeFromDOM();
      this.insertInDOM();
    }
  }
};
function render$s(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_w_card = resolveComponent("w-card");
  const _component_w_overlay = resolveComponent("w-overlay");
  return openBlock(), createElementBlock(Fragment, null, [
    renderSlot(_ctx.$slots, "activator", { on: $options.activatorEventHandlers }),
    createVNode(Transition, {
      name: $options.transitionName,
      appear: ""
    }, {
      default: withCtx(() => [
        $props.custom && _ctx.detachableVisible ? (openBlock(), createElementBlock("div", mergeProps({
          key: 0,
          class: "w-menu",
          ref: "detachable"
        }, _ctx.$attrs, {
          onClick: _cache[0] || (_cache[0] = ($event) => $props.hideOnMenuClick && $options.close(true)),
          onMouseenter: _cache[1] || (_cache[1] = ($event) => $props.showOnHover && (_ctx.hoveringMenu = true)),
          onMouseleave: _cache[2] || (_cache[2] = ($event) => $props.showOnHover && (_ctx.hoveringMenu = false, $options.close())),
          class: $options.classes,
          style: $options.styles
        }), [
          renderSlot(_ctx.$slots, "default")
        ], 16)) : _ctx.detachableVisible ? (openBlock(), createBlock(_component_w_card, mergeProps({
          key: 1,
          class: "w-menu",
          ref: "detachable"
        }, _ctx.$attrs, {
          onClick: _cache[3] || (_cache[3] = ($event) => $props.hideOnMenuClick && $options.close(true)),
          onMouseenter: _cache[4] || (_cache[4] = ($event) => $props.showOnHover && (_ctx.hoveringMenu = true)),
          onMouseleave: _cache[5] || (_cache[5] = ($event) => $props.showOnHover && (_ctx.hoveringMenu = false, $options.close())),
          tile: $props.tile,
          "title-class": $options.titleClasses,
          "content-class": $options.contentClasses,
          shadow: $props.shadow,
          "no-border": $props.noBorder,
          class: $options.classes,
          style: $options.styles
        }), createSlots({
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "default")
          ]),
          _: 2
        }, [
          _ctx.$slots.title ? {
            name: "title",
            fn: withCtx(() => [
              renderSlot(_ctx.$slots, "title")
            ]),
            key: "0"
          } : void 0,
          _ctx.$slots.actions ? {
            name: "actions",
            fn: withCtx(() => [
              renderSlot(_ctx.$slots, "actions")
            ]),
            key: "1"
          } : void 0
        ]), 1040, ["tile", "title-class", "content-class", "shadow", "no-border", "class", "style"])) : createCommentVNode("", true)
      ]),
      _: 3
    }, 8, ["name"]),
    $props.overlay ? (openBlock(), createBlock(_component_w_overlay, mergeProps({
      key: 0,
      ref: "overlay",
      "model-value": _ctx.detachableVisible,
      persistent: $props.persistent,
      class: $options.overlayClasses
    }, $props.overlayProps, {
      "z-index": (_ctx.zIndex || 200) - 1,
      "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => _ctx.detachableVisible = false)
    }), null, 16, ["model-value", "persistent", "class", "z-index"])) : createCommentVNode("", true)
  ], 64);
}
var wMenu_vue_vue_type_style_index_0_lang = "";
const _sfc_main$s = {
  name: "w-menu",
  mixins: [DetachableMixin],
  props: {
    modelValue: {},
    showOnHover: { type: Boolean },
    hideOnMenuClick: { type: Boolean },
    color: { type: String },
    bgColor: { type: String },
    shadow: { type: Boolean },
    custom: { type: Boolean },
    tile: { type: Boolean },
    round: { type: Boolean },
    noBorder: { type: Boolean },
    transition: { type: String },
    menuClass: { type: [String, Object, Array] },
    titleClass: { type: [String, Object, Array] },
    contentClass: { type: [String, Object, Array] },
    arrow: { type: Boolean },
    minWidth: { type: [Number, String] },
    overlay: { type: Boolean },
    overlayClass: { type: [String, Object, Array] },
    overlayProps: { type: Object },
    persistent: { type: Boolean },
    delay: { type: Number }
  },
  provide() {
    return {
      detachableDefaultRoot: () => {
        var _a;
        return ((_a = this.$refs.detachable) == null ? void 0 : _a.$el) || this.$refs.detachable || null;
      }
    };
  },
  emits: ["input", "update:modelValue", "open", "close"],
  data: () => ({
    detachableVisible: false,
    hoveringActivator: false,
    hoveringMenu: false,
    detachableCoords: {
      top: 0,
      left: 0
    },
    activatorWidth: 0,
    detachableEl: null,
    timeoutId: null
  }),
  computed: {
    transitionName() {
      return this.transition || "scale-fade";
    },
    menuMinWidth() {
      if (this.minWidth === "activator")
        return this.activatorWidth ? `${this.activatorWidth}px` : 0;
      else
        return isNaN(this.minWidth) ? this.minWidth : this.minWidth ? `${this.minWidth}px` : 0;
    },
    menuClasses() {
      return objectifyClasses(this.menuClass);
    },
    titleClasses() {
      return objectifyClasses(this.titleClass);
    },
    contentClasses() {
      return objectifyClasses(this.contentClass);
    },
    overlayClasses() {
      return {
        ...objectifyClasses(this.overlayClass),
        "w-overlay--no-pointer-event": this.showOnHover
      };
    },
    classes() {
      return {
        [this.color]: this.color,
        [`${this.bgColor}--bg`]: this.bgColor,
        ...this.menuClasses,
        [`w-menu--${this.position}`]: !this.noPosition,
        [`w-menu--align-${this.alignment}`]: !this.noPosition && this.alignment,
        "w-menu--tile": this.tile,
        "w-menu--card": !this.custom,
        "w-menu--round": this.round,
        "w-menu--arrow": this.arrow,
        "w-menu--shadow": this.shadow,
        "w-menu--fixed": this.fixed
      };
    },
    styles() {
      return {
        zIndex: this.zIndex || this.zIndex === 0 || this.overlay && !this.zIndex && 200 || null,
        top: this.detachableCoords.top && `${~~this.detachableCoords.top}px` || null,
        left: this.detachableCoords.left && `${~~this.detachableCoords.left}px` || null,
        minWidth: this.minWidth && this.menuMinWidth || null,
        "--w-menu-bg-color": this.arrow && this.$waveui.colors[this.bgColor || "white"]
      };
    },
    activatorEventHandlers() {
      let handlers = {};
      if (this.showOnHover) {
        handlers = {
          focus: this.toggle,
          blur: this.toggle,
          mouseenter: (e) => {
            this.hoveringActivator = true;
            this.open(e);
          },
          mouseleave: (e) => {
            this.hoveringActivator = false;
            setTimeout(() => {
              if (!this.hoveringMenu)
                this.close();
            }, 10);
          }
        };
        if (typeof window !== "undefined" && "ontouchstart" in window) {
          handlers.click = this.toggle;
        }
      } else
        handlers = { click: this.toggle };
      return handlers;
    }
  },
  methods: {
    toggle(e) {
      let shouldShowMenu = this.detachableVisible;
      if (typeof window !== "undefined" && "ontouchstart" in window && this.showOnHover && e.type === "click") {
        shouldShowMenu = !shouldShowMenu;
      } else if (e.type === "click" && !this.showOnHover)
        shouldShowMenu = !shouldShowMenu;
      else if (e.type === "mouseenter" && this.showOnHover) {
        this.hoveringActivator = true;
        shouldShowMenu = true;
      } else if (e.type === "mouseleave" && this.showOnHover) {
        this.hoveringActivator = false;
        shouldShowMenu = false;
      }
      this.timeoutId = clearTimeout(this.timeoutId);
      if (shouldShowMenu)
        this.open(e);
      else
        this.close();
    },
    async close(force = false) {
      if (!this.detachableVisible)
        return;
      if (this.showOnHover && !force) {
        await new Promise((resolve) => setTimeout(resolve, 10));
        if (this.showOnHover && (this.hoveringMenu || this.hoveringActivator))
          return;
      }
      this.$emit("update:modelValue", this.detachableVisible = false);
      this.$emit("input", false);
      this.$emit("close");
      document.removeEventListener("mousedown", this.onOutsideMousedown);
      window.removeEventListener("resize", this.onResize);
    }
  }
};
var wMenu = /* @__PURE__ */ _export_sfc(_sfc_main$s, [["render", render$s]]);
function render$r(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_w_alert = resolveComponent("w-alert");
  return openBlock(), createBlock(Transition, {
    name: $options.transitionName,
    appear: ""
  }, {
    default: withCtx(() => [
      $data.show ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: normalizeClass(["w-notification", $options.classes]),
        style: normalizeStyle($options.styles)
      }, [
        createVNode(_component_w_alert, mergeProps($options.alertProps, {
          class: $options.alertClasses,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => {
            _ctx.$emit("update:modelValue", false);
            _ctx.$emit("input", false);
          })
        }), {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "default")
          ]),
          _: 3
        }, 16, ["class"])
      ], 6)) : createCommentVNode("", true)
    ]),
    _: 3
  }, 8, ["name"]);
}
var wNotification_vue_vue_type_style_index_0_lang = "";
const _sfc_main$r = {
  name: "w-notification",
  props: {
    modelValue: { default: true },
    transition: { type: [String, Boolean], default: "" },
    timeout: { type: [Number, String], default: 0 },
    absolute: { type: Boolean },
    top: { type: Boolean },
    bottom: { type: Boolean },
    left: { type: Boolean },
    right: { type: Boolean },
    zIndex: { type: [Number, String, Boolean] },
    success: { type: Boolean },
    info: { type: Boolean },
    warning: { type: Boolean },
    error: { type: Boolean },
    color: { type: String },
    bgColor: { type: String },
    shadow: { type: Boolean },
    tile: { type: Boolean },
    round: { type: Boolean },
    plain: { type: Boolean },
    noBorder: { type: Boolean },
    borderLeft: { type: Boolean },
    borderRight: { type: Boolean },
    borderTop: { type: Boolean },
    borderBottom: { type: Boolean },
    outline: { type: Boolean },
    dismiss: { type: Boolean },
    xs: { type: Boolean },
    sm: { type: Boolean },
    md: { type: Boolean },
    lg: { type: Boolean },
    xl: { type: Boolean }
  },
  emits: ["input", "update:modelValue", "close"],
  data() {
    return {
      show: this.modelValue,
      timeoutId: null
    };
  },
  computed: {
    transitionName() {
      if (this.transition === false)
        return "";
      if (!this.transition) {
        const opposites = { top: "down", bottom: "up", left: "right", right: "left" };
        return `slide-${opposites[this.position[this.position[1] === "center" ? 0 : 1]]}`;
      }
      return this.transition;
    },
    position() {
      let position = [];
      if (!this.top && !this.bottom && !this.left && !this.right)
        position = ["top", "right"];
      else {
        position = [
          this.top && "top" || this.bottom && "bottom" || "top",
          this.left && "left" || this.right && "right" || "center"
        ];
      }
      return position;
    },
    hasType() {
      return !!(this.success || this.info || this.warning || this.error);
    },
    alertProps() {
      return {
        modelValue: this.show,
        success: this.success,
        info: this.info,
        warning: this.warning,
        error: this.error,
        color: this.color,
        bgColor: this.bgColor || !this.hasType && "white" || "",
        shadow: this.shadow,
        tile: this.tile,
        round: this.round,
        plain: this.plain,
        noBorder: this.noBorder,
        borderLeft: this.borderLeft,
        borderRight: this.borderRight,
        borderTop: this.borderTop,
        borderBottom: this.borderBottom,
        outline: this.outline,
        dismiss: this.dismiss,
        xs: this.xs,
        sm: this.sm,
        md: this.md,
        lg: this.lg,
        xl: this.xl
      };
    },
    classes() {
      return {
        "w-notification--absolute": this.absolute,
        [`w-notification--${this.position.join(" w-notification--")}`]: true
      };
    },
    alertClasses() {
      if (this.bgColor || (this.success || this.info || this.warning || this.error) && this.plain)
        return null;
      return "white--bg";
    },
    styles() {
      return {
        zIndex: this.zIndex || this.zIndex === 0 || null
      };
    },
    timeoutVal() {
      return parseInt(this.timeout);
    }
  },
  methods: {
    countdown() {
      this.timeoutId = setTimeout(() => {
        this.$emit("update:modelValue", this.show = false);
        this.$emit("input", false);
        this.$emit("close");
      }, this.timeoutVal);
    }
  },
  created() {
    if (this.modelValue && this.timeoutVal)
      this.countdown();
  },
  watch: {
    modelValue(value) {
      clearTimeout(this.timeoutId);
      this.show = value;
      if (value && this.timeoutVal)
        this.countdown();
    }
  }
};
var wNotification = /* @__PURE__ */ _export_sfc(_sfc_main$r, [["render", render$r]]);
function render$q(_ctx, _cache, $props, $setup, $data, $options) {
  const _directive_focus = resolveDirective("focus");
  return openBlock(), createBlock(Transition, {
    name: "fade",
    appear: "",
    onAfterLeave: $options.onClose
  }, {
    default: withCtx(() => [
      $props.modelValue ? withDirectives((openBlock(), createElementBlock("div", {
        key: 0,
        class: normalizeClass(["w-overlay", $options.classes]),
        ref: "overlay",
        style: normalizeStyle($props.modelValue && $options.styles || null),
        onKeydown: _cache[0] || (_cache[0] = withKeys(withModifiers((...args) => $options.onClick && $options.onClick(...args), ["stop"]), ["escape"])),
        onClick: _cache[1] || (_cache[1] = (...args) => $options.onClick && $options.onClick(...args)),
        tabindex: "0"
      }, [
        renderSlot(_ctx.$slots, "default")
      ], 38)), [
        [vShow, _ctx.showOverlay],
        [_directive_focus]
      ]) : createCommentVNode("", true)
    ]),
    _: 3
  }, 8, ["onAfterLeave"]);
}
var wOverlay_vue_vue_type_style_index_0_lang = "";
const _sfc_main$q = {
  name: "w-overlay",
  props: {
    modelValue: {},
    opacity: { type: [Number, String, Boolean] },
    bgColor: { type: String },
    zIndex: { type: [Number, String, Boolean] },
    persistent: { type: Boolean },
    persistentNoAnimation: { type: Boolean }
  },
  provide() {
    return {
      detachableDefaultRoot: () => this.$refs.overlay || null
    };
  },
  emits: ["input", "update:modelValue", "click", "before-close", "close"],
  data: () => ({
    persistentAnimate: false,
    showOverlay: false
  }),
  computed: {
    backgroundColor() {
      return this.bgColor || this.opacity && `rgba(0, 0, 0, ${this.opacity})` || false;
    },
    classes() {
      return {
        "w-overlay--persistent-animate": this.persistentAnimate
      };
    },
    styles() {
      return {
        backgroundColor: this.backgroundColor,
        zIndex: this.zIndex || this.zIndex === 0 ? this.zIndex : false
      };
    }
  },
  methods: {
    onClick(e) {
      if (!e.target.classList.contains("w-overlay"))
        return;
      if (this.persistent && !this.persistentNoAnimation) {
        this.persistentAnimate = true;
        setTimeout(() => this.persistentAnimate = false, 150);
      } else if (!this.persistent) {
        this.showOverlay = false;
        this.$emit("before-close");
      }
      this.$emit("click", e);
    },
    onClose() {
      this.$emit("update:modelValue", false);
      this.$emit("input", false);
      if (!this.modelValue)
        this.$emit("close");
    }
  },
  created() {
    this.showOverlay = this.modelValue;
  },
  watch: {
    modelValue(bool) {
      if (bool)
        this.showOverlay = true;
    }
  }
};
var wOverlay = /* @__PURE__ */ _export_sfc(_sfc_main$q, [["render", render$q]]);
const _hoisted_1$f = { class: "w-parallax" };
function render$p(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$f);
}
var wParallax_vue_vue_type_style_index_0_lang = "";
const _sfc_main$p = {
  name: "w-parallax",
  props: {},
  emits: [],
  data: () => ({})
};
var wParallax = /* @__PURE__ */ _export_sfc(_sfc_main$p, [["render", render$p]]);
const _hoisted_1$e = ["viewBox"];
const _hoisted_2$9 = ["cx", "cy", "r", "stroke-dasharray", "stroke-width"];
const _hoisted_3$8 = ["viewBox"];
const _hoisted_4$6 = ["cx", "cy", "r", "stroke-width", "stroke-linecap", "stroke-dasharray"];
function render$o(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["w-progress", $options.classes]),
    style: normalizeStyle($options.styles)
  }, [
    !$props.circle ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: normalizeClass(["w-progress__progress", { full: $options.progressValue === 100 }]),
      style: normalizeStyle(`width: ${$options.progressValue}%`)
    }, null, 6)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
      (openBlock(), createElementBlock("svg", {
        viewBox: `${$options.circleCenter / 2} ${$options.circleCenter / 2} ${$options.circleCenter} ${$options.circleCenter}`
      }, [
        $props.bgColor || this.progressValue > -1 ? (openBlock(), createElementBlock("circle", {
          key: 0,
          class: normalizeClass(["bg", $props.bgColor]),
          cx: $options.circleCenter,
          cy: $options.circleCenter,
          r: _ctx.circleRadius,
          fill: "transparent",
          "stroke-dasharray": _ctx.circleCircumference,
          "stroke-width": $props.stroke
        }, null, 10, _hoisted_2$9)) : createCommentVNode("", true)
      ], 8, _hoisted_1$e)),
      (openBlock(), createElementBlock("svg", {
        class: "w-progress__progress",
        viewBox: `${$options.circleCenter / 2} ${$options.circleCenter / 2} ${$options.circleCenter} ${$options.circleCenter}`,
        style: normalizeStyle(`stroke-dashoffset: ${(1 - $options.progressValue / 100) * _ctx.circleCircumference}`)
      }, [
        createElementVNode("circle", {
          cx: $options.circleCenter,
          cy: $options.circleCenter,
          r: _ctx.circleRadius,
          fill: "transparent",
          "stroke-width": $props.stroke,
          "stroke-linecap": $props.roundCap && "round",
          "stroke-dasharray": _ctx.circleCircumference
        }, null, 8, _hoisted_4$6)
      ], 12, _hoisted_3$8))
    ], 64)),
    $props.label || _ctx.$slots.default ? (openBlock(), createElementBlock("div", {
      key: 2,
      class: normalizeClass(["w-progress__label", $props.labelColor || false])
    }, [
      renderSlot(_ctx.$slots, "default", {}, () => [
        createTextVNode(toDisplayString(Math.round($options.progressValue)) + toDisplayString($props.circle ? "" : "%"), 1)
      ])
    ], 2)) : createCommentVNode("", true)
  ], 6);
}
var wProgress_vue_vue_type_style_index_0_lang = "";
const circleSize = 40;
const circleRadius = circleSize / 2;
const circleCircumference = Math.round(circleSize * 3.14 * 100) / 100;
const _sfc_main$o = {
  name: "w-progress",
  props: {
    modelValue: { type: [Number, String, Boolean], default: -1 },
    label: { type: Boolean },
    roundCap: { type: Boolean },
    color: { type: String, default: "primary" },
    bgColor: { type: String },
    labelColor: { type: String },
    size: { type: [Number, String] },
    circle: { type: Boolean },
    stroke: { type: [Number, String], default: 4 },
    shadow: { type: Boolean },
    tile: { type: Boolean },
    round: { type: Boolean },
    outline: { type: Boolean },
    stripes: { type: Boolean },
    absolute: { type: Boolean },
    fixed: { type: Boolean },
    top: { type: Boolean },
    bottom: { type: Boolean },
    zIndex: { type: [Number, String, Boolean] }
  },
  emits: [],
  data: () => ({
    circleSize,
    circleRadius,
    circleCircumference
  }),
  computed: {
    progressValue() {
      return parseFloat(this.modelValue);
    },
    circleCenter() {
      return circleSize + this.stroke;
    },
    forcedSize() {
      return this.size && (!isNaN(this.size) ? `${this.size}px` : this.size);
    },
    position() {
      return this.top && "top" || this.bottom && "bottom" || "top";
    },
    classes() {
      return {
        [`w-progress--${this.circle ? "circular" : "linear"}`]: true,
        [this.color]: this.color,
        [`${this.bgColor}--bg`]: this.bgColor && !this.circle,
        [`w-progress--${this.position}`]: !this.circle && (this.absolute || this.fixed),
        "w-progress--default-bg": !this.bgColor,
        "w-progress--indeterminate": this.modelValue === -1,
        "w-progress--outline": !this.circle && this.outline,
        "w-progress--tile": !this.circle && this.tile,
        "w-progress--stripes": !this.circle && this.stripes,
        "w-progress--round": !this.circle && this.round,
        "w-progress--shadow": this.shadow,
        "w-progress--absolute": !this.circle && this.absolute,
        "w-progress--fixed": !this.circle && !this.absolute && this.fixed,
        [`w-progress--${this.roundCap ? "round" : "flat"}-cap`]: true
      };
    },
    styles() {
      return {
        [this.circle ? "width" : "height"]: this.forcedSize || null
      };
    }
  }
};
var wProgress = /* @__PURE__ */ _export_sfc(_sfc_main$o, [["render", render$o]]);
const _hoisted_1$d = ["id", "name", "checked", "disabled", "required", "tabindex", "aria-checked"];
const _hoisted_2$8 = ["for"];
const _hoisted_3$7 = ["for"];
function render$n(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(resolveDynamicComponent(_ctx.formRegister && !$options.wRadios ? "w-form-element" : "div"), mergeProps({ ref: "formEl" }, _ctx.formRegister && { validators: _ctx.validators, inputValue: _ctx.inputValue, disabled: _ctx.isDisabled }, {
    valid: _ctx.valid,
    "onUpdate:valid": _cache[3] || (_cache[3] = ($event) => _ctx.valid = $event),
    onReset: _cache[4] || (_cache[4] = ($event) => {
      _ctx.$emit("update:modelValue", _ctx.inputValue = null);
      _ctx.$emit("input", null);
    }),
    class: $options.classes
  }), {
    default: withCtx(() => [
      createElementVNode("input", {
        ref: "input",
        id: `w-radio--${_ctx._.uid}`,
        type: "radio",
        name: _ctx.inputName,
        checked: _ctx.inputValue || null,
        disabled: _ctx.isDisabled || null,
        required: _ctx.required || null,
        tabindex: _ctx.tabindex || null,
        onFocus: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("focus", $event)),
        onChange: _cache[1] || (_cache[1] = ($event) => $options.onInput($event)),
        "aria-checked": _ctx.inputValue || "false",
        role: "radio"
      }, null, 40, _hoisted_1$d),
      $options.hasLabel && $props.labelOnLeft ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
        _ctx.$slots.default || $props.label ? (openBlock(), createElementBlock("label", {
          key: 0,
          class: normalizeClass(["w-radio__label w-form-el-shakable pr2", _ctx.labelClasses]),
          for: `w-radio--${_ctx._.uid}`
        }, [
          renderSlot(_ctx.$slots, "default", {}, () => [
            createTextVNode(toDisplayString($props.label), 1)
          ])
        ], 10, _hoisted_2$8)) : createCommentVNode("", true)
      ], 64)) : createCommentVNode("", true),
      createElementVNode("div", {
        class: normalizeClass(["w-radio__input", this.color]),
        onClick: _cache[2] || (_cache[2] = ($event) => {
          _ctx.$refs.input.focus();
          _ctx.$refs.input.click();
        })
      }, null, 2),
      $options.hasLabel && !$props.labelOnLeft ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
        _ctx.$slots.default || $props.label ? (openBlock(), createElementBlock("label", {
          key: 0,
          class: normalizeClass(["w-radio__label w-form-el-shakable pl2", _ctx.labelClasses]),
          for: `w-radio--${_ctx._.uid}`
        }, [
          renderSlot(_ctx.$slots, "default", {}, () => [
            createTextVNode(toDisplayString($props.label), 1)
          ])
        ], 10, _hoisted_3$7)) : createCommentVNode("", true)
      ], 64)) : createCommentVNode("", true)
    ]),
    _: 3
  }, 16, ["valid", "class"]);
}
var wRadio_vue_vue_type_style_index_0_lang = "";
const _sfc_main$n = {
  name: "w-radio",
  mixins: [FormElementMixin],
  inject: { wRadios: { default: null } },
  props: {
    modelValue: { default: false },
    returnValue: {},
    label: { type: String },
    labelOnLeft: { type: Boolean },
    color: { type: String, default: "primary" },
    labelColor: { type: String, default: "primary" },
    noRipple: { type: Boolean }
  },
  emits: ["input", "update:modelValue", "focus"],
  data: () => ({
    inputValue: false,
    ripple: {
      start: false,
      end: false,
      timeout: null
    }
  }),
  computed: {
    hasLabel() {
      return this.label || this.$slots.default;
    },
    classes() {
      return {
        [`w-radio w-radio--${this.inputValue ? "checked" : "unchecked"}`]: true,
        "w-radio--disabled": this.isDisabled,
        "w-radio--ripple": this.ripple.start,
        "w-radio--rippled": this.ripple.end
      };
    }
  },
  methods: {
    toggleFromOutside() {
      this.inputValue = this.returnValue !== void 0 ? this.returnValue === this.modelValue : this.modelValue;
    },
    onInput(e) {
      this.inputValue = e.target.checked;
      const returnValue = this.inputValue && this.returnValue !== void 0 ? this.returnValue : this.inputValue;
      this.$emit("update:modelValue", returnValue);
      this.$emit("input", returnValue);
      if (!this.noRipple) {
        if (this.inputValue) {
          this.ripple.start = true;
          this.ripple.timeout = setTimeout(() => {
            this.ripple.start = false;
            this.ripple.end = true;
            setTimeout(() => this.ripple.end = false, 100);
          }, 700);
        } else {
          this.ripple.start = false;
          clearTimeout(this.ripple.timeout);
        }
      }
    }
  },
  created() {
    if (this.modelValue !== void 0)
      this.toggleFromOutside();
  },
  watch: {
    modelValue() {
      this.toggleFromOutside();
    }
  }
};
var wRadio = /* @__PURE__ */ _export_sfc(_sfc_main$n, [["render", render$n]]);
const _hoisted_1$c = ["innerHTML"];
function render$m(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_w_radio = resolveComponent("w-radio");
  return openBlock(), createBlock(resolveDynamicComponent(_ctx.formRegister ? "w-form-element" : "div"), mergeProps({ ref: "formEl" }, _ctx.formRegister && { validators: _ctx.validators, inputValue: _ctx.inputValue, disabled: _ctx.isDisabled }, {
    valid: _ctx.valid,
    "onUpdate:valid": _cache[1] || (_cache[1] = ($event) => _ctx.valid = $event),
    onReset: _cache[2] || (_cache[2] = ($event) => {
      _ctx.$emit("update:modelValue", _ctx.inputValue = null);
      _ctx.$emit("input", null);
    }),
    column: !$props.inline,
    wrap: $props.inline,
    class: $options.classes
  }), {
    default: withCtx(() => [
      (openBlock(true), createElementBlock(Fragment, null, renderList($options.radioItems, (item, i) => {
        return openBlock(), createBlock(_component_w_radio, mergeProps({
          key: i,
          "model-value": item.value === $props.modelValue,
          "onUpdate:modelValue": ($event) => $options.onInput(item),
          onFocus: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("focus", $event)),
          name: _ctx.inputName
        }, { label: item.label, color: item.color, labelOnLeft: $props.labelOnLeft, labelColor: $props.labelColor }, {
          disabled: _ctx.isDisabled || null,
          readonly: _ctx.isReadonly || null,
          class: { mt1: !$props.inline && i }
        }), {
          default: withCtx(() => [
            _ctx.$slots[`item.${i + 1}`] || _ctx.$slots.item ? renderSlot(_ctx.$slots, _ctx.$slots[`item.${i + 1}`] ? `item.${i + 1}` : "item", {
              key: 0,
              item: $options.getOriginalItem(item),
              index: i + 1,
              checked: item.value === $props.modelValue,
              innerHTML: item.label
            }) : item.label ? (openBlock(), createElementBlock("div", {
              key: 1,
              innerHTML: item.label
            }, null, 8, _hoisted_1$c)) : createCommentVNode("", true)
          ]),
          _: 2
        }, 1040, ["model-value", "onUpdate:modelValue", "name", "disabled", "readonly", "class"]);
      }), 128))
    ]),
    _: 3
  }, 16, ["valid", "column", "wrap", "class"]);
}
var wRadios_vue_vue_type_style_index_0_lang = "";
const _sfc_main$m = {
  name: "w-radios",
  mixins: [FormElementMixin],
  props: {
    items: { type: Array, required: true },
    modelValue: { type: [String, Number, Boolean] },
    labelOnLeft: { type: Boolean },
    itemLabelKey: { type: String, default: "label" },
    itemValueKey: { type: String, default: "value" },
    itemColorKey: { type: String, default: "color" },
    inline: { type: Boolean },
    color: { type: String, default: "primary" },
    labelColor: { type: String, default: "primary" }
  },
  emits: ["input", "update:modelValue", "focus"],
  provide() {
    return { wRadios: true };
  },
  data: () => ({
    inputValue: null
  }),
  computed: {
    radioItems() {
      return (this.items || []).map((item, i) => ({
        ...item,
        _index: i,
        label: item[this.itemLabelKey],
        value: item[this.itemValueKey] === void 0 ? item[this.itemLabelKey] || i : item[this.itemValueKey],
        color: item[this.itemColorKey] || this.color
      }));
    },
    classes() {
      return [
        "w-radios",
        `w-radios--${this.inline ? "inline" : "column"}`
      ];
    }
  },
  methods: {
    onInput(item) {
      this.inputValue = true;
      this.$emit("update:modelValue", item.value);
      this.$emit("input", item.value);
    },
    getOriginalItem(item) {
      return this.items[item._index];
    }
  }
};
var wRadios = /* @__PURE__ */ _export_sfc(_sfc_main$m, [["render", render$m]]);
const _hoisted_1$b = ["id", "name", "value"];
const _hoisted_2$7 = ["disabled", "onMouseenter", "onClick", "tabindex"];
function render$l(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(resolveDynamicComponent(_ctx.formRegister ? "w-form-element" : "div"), mergeProps({ ref: "formEl" }, _ctx.formRegister && { validators: _ctx.validators, inputValue: $data.rating, disabled: _ctx.isDisabled, readonly: _ctx.isReadonly }, {
    valid: _ctx.valid,
    "onUpdate:valid": _cache[4] || (_cache[4] = ($event) => _ctx.valid = $event),
    onReset: _cache[5] || (_cache[5] = ($event) => {
      _ctx.$emit("update:modelValue", $data.rating = null);
      _ctx.$emit("input", null);
    }),
    class: $options.classes
  }), {
    default: withCtx(() => [
      createElementVNode("input", {
        id: _ctx.inputName,
        name: _ctx.inputName,
        type: "hidden",
        value: $data.rating
      }, null, 8, _hoisted_1$b),
      (openBlock(true), createElementBlock(Fragment, null, renderList($props.max, (i) => {
        return openBlock(), createElementBlock(Fragment, { key: i }, [
          _ctx.$slots.item ? renderSlot(_ctx.$slots, "item", {
            key: 0,
            index: i + 1
          }) : createCommentVNode("", true),
          createElementVNode("button", {
            class: normalizeClass(["w-rating__button", $options.buttonClasses(i)]),
            disabled: _ctx.isDisabled || _ctx.isReadonly,
            onMouseenter: ($event) => $data.hover = i,
            onMouseleave: _cache[0] || (_cache[0] = ($event) => $data.hover = 0),
            onClick: ($event) => $options.onButtonClick(i),
            onFocus: _cache[1] || (_cache[1] = (...args) => $options.onFocus && $options.onFocus(...args)),
            onBlur: _cache[2] || (_cache[2] = (...args) => $options.onBlur && $options.onBlur(...args)),
            onKeydown: _cache[3] || (_cache[3] = (...args) => $options.onKeydown && $options.onKeydown(...args)),
            type: "button",
            tabindex: i === 1 ? 0 : -1
          }, [
            i - 1 === ~~$data.rating && $data.rating - ~~$data.rating ? (openBlock(), createElementBlock("i", {
              key: 0,
              class: normalizeClass(["w-icon", `${$props.icon} ${$props.color}`]),
              role: "icon",
              "aria-hidden": "true",
              style: normalizeStyle($options.halfStarStyle)
            }, null, 6)) : createCommentVNode("", true)
          ], 42, _hoisted_2$7)
        ], 64);
      }), 128))
    ]),
    _: 3
  }, 16, ["valid", "class"]);
}
var wRating_vue_vue_type_style_index_0_lang = "";
const _sfc_main$l = {
  name: "w-rating",
  mixins: [FormElementMixin],
  props: {
    modelValue: {},
    max: { type: [Number, String], default: 5 },
    color: { type: String, default: "primary" },
    bgColor: { type: String, default: "grey-light4" },
    icon: { type: String, default: "wi-star" },
    xs: { type: Boolean },
    sm: { type: Boolean },
    md: { type: Boolean },
    lg: { type: Boolean },
    xl: { type: Boolean },
    noRipple: { type: Boolean }
  },
  emits: ["input", "update:modelValue", "focus", "blur"],
  data() {
    return {
      rating: parseFloat(this.modelValue || 0),
      hover: 0,
      hasFocus: 0,
      ripple: {
        start: false,
        end: false,
        timeout: null
      }
    };
  },
  computed: {
    size() {
      return this.xs && "xs" || this.sm && "sm" || this.lg && "lg" || this.xl && "xl" || "md";
    },
    classes() {
      return {
        "w-rating": true,
        "w-rating--focus": this.hasFocus,
        "w-rating--hover": this.hover,
        "w-rating--disabled": this.isDisabled,
        "w-rating--readonly": this.isReadonly,
        "w-rating--ripple": this.ripple.start,
        "w-rating--rippled": this.ripple.end
      };
    },
    halfStarStyle() {
      return {
        width: this.hover <= ~~this.rating && `${(this.rating - ~~this.rating) * 100}%`
      };
    }
  },
  methods: {
    onButtonClick(i) {
      this.rating = i;
      this.$emit("update:modelValue", this.rating);
      this.$emit("input", this.rating);
      if (!this.noRipple) {
        this.ripple.start = true;
        this.ripple.timeout = setTimeout(() => {
          this.ripple.start = false;
          this.ripple.end = true;
          setTimeout(() => this.ripple.end = false, 100);
        }, 700);
      }
    },
    onFocus(e) {
      this.hasFocus = true;
      this.$emit("focus", e);
    },
    onBlur(e) {
      this.hasFocus = false;
      this.$emit("blur", e);
    },
    onKeydown(e) {
      if ([37, 38, 39, 40].includes(e.keyCode)) {
        if ([39, 40].includes(e.keyCode))
          this.rating <= this.max - 1 && this.rating++;
        else if (this.rating > 1)
          this.rating--;
        const sibling = this.$el.querySelectorAll("button")[this.rating - 1];
        if (sibling) {
          sibling.focus();
          sibling.click();
        }
        e.preventDefault();
      }
    },
    buttonClasses(i) {
      const isHalf = i - 1 === ~~this.rating && this.rating - ~~this.rating;
      const isOn = this.hover >= i || !isHalf && this.hover === 0 && this.rating >= i;
      return {
        "w-rating__button--on": isOn,
        "w-rating__button--half": isHalf,
        [this.icon]: true,
        [`size--${this.size}`]: true,
        [isOn ? this.color : this.bgColor]: true
      };
    }
  },
  watch: {
    value(value) {
      this.rating = parseFloat(value);
    }
  }
};
var wRating = /* @__PURE__ */ _export_sfc(_sfc_main$l, [["render", render$l]]);
const _hoisted_1$a = ["for"];
const _hoisted_2$6 = ["aria-expanded", "aria-owns", "aria-activedescendant"];
const _hoisted_3$6 = {
  key: 1,
  class: "w-select__selection-slot"
};
const _hoisted_4$5 = ["value", "id", "placeholder", "disabled", "required", "tabindex"];
const _hoisted_5$4 = ["value", "name"];
const _hoisted_6$2 = ["for"];
const _hoisted_7$2 = ["for"];
function render$k(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_w_icon = resolveComponent("w-icon");
  const _component_w_list = resolveComponent("w-list");
  const _component_w_menu = resolveComponent("w-menu");
  return openBlock(), createBlock(resolveDynamicComponent(_ctx.formRegister ? "w-form-element" : "div"), mergeProps({ ref: "formEl" }, _ctx.formRegister && { validators: _ctx.validators, inputValue: $options.selectionString, disabled: _ctx.isDisabled, readonly: _ctx.isReadonly }, {
    valid: _ctx.valid,
    "onUpdate:valid": _cache[9] || (_cache[9] = ($event) => _ctx.valid = $event),
    onReset: $options.onReset,
    wrap: $options.hasLabel && $props.labelPosition !== "inside",
    class: $options.classes
  }), {
    default: withCtx(() => [
      $props.labelPosition === "left" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
        _ctx.$slots.default || $props.label ? (openBlock(), createElementBlock("label", {
          key: 0,
          class: normalizeClass(["w-select__label w-select__label--left w-form-el-shakable", _ctx.labelClasses]),
          for: `w-select--${_ctx._.uid}`
        }, [
          renderSlot(_ctx.$slots, "default", {}, () => [
            createTextVNode(toDisplayString($props.label), 1)
          ])
        ], 10, _hoisted_1$a)) : createCommentVNode("", true)
      ], 64)) : createCommentVNode("", true),
      createVNode(_component_w_menu, mergeProps({
        modelValue: _ctx.showMenu,
        "onUpdate:modelValue": _cache[8] || (_cache[8] = ($event) => _ctx.showMenu = $event),
        "menu-class": `w-select__menu ${$props.menuClass || ""}`,
        transition: "slide-fade-down",
        "append-to": ($props.menuProps || {}).appendTo !== void 0 ? ($props.menuProps || {}).appendTo : void 0,
        "align-left": "",
        custom: "",
        "min-width": "activator"
      }, $props.menuProps || {}), {
        activator: withCtx(({ on }) => [
          createElementVNode("div", {
            class: normalizeClass(["w-select__selection-wrap", $options.inputWrapClasses]),
            onClick: _cache[5] || (_cache[5] = ($event) => !_ctx.isDisabled && !_ctx.isReadonly && (_ctx.showMenu ? $options.closeMenu : $options.openMenu)()),
            role: "button",
            "aria-haspopup": "listbox",
            "aria-expanded": _ctx.showMenu ? "true" : "false",
            "aria-owns": `w-select-menu--${_ctx._.uid}`,
            "aria-activedescendant": `w-select-menu--${_ctx._.uid}_item-1`
          }, [
            $props.innerIconLeft ? (openBlock(), createBlock(_component_w_icon, {
              key: 0,
              class: "w-select__icon w-select__icon--inner-left",
              tag: "label",
              onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click:inner-icon-left", $event))
            }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString($props.innerIconLeft), 1)
              ]),
              _: 1
            })) : createCommentVNode("", true),
            _ctx.$slots.selection ? (openBlock(), createElementBlock("div", _hoisted_3$6, [
              renderSlot(_ctx.$slots, "selection", {
                item: $props.multiple ? _ctx.inputValue : _ctx.inputValue[0]
              })
            ])) : createCommentVNode("", true),
            createElementVNode("input", {
              class: "w-select__selection",
              ref: "selection-input",
              type: "text",
              value: _ctx.$slots.selection ? "" : $options.selectionString,
              onFocus: _cache[1] || (_cache[1] = ($event) => !_ctx.isDisabled && !_ctx.isReadonly && $options.onFocus($event)),
              onBlur: _cache[2] || (_cache[2] = (...args) => $options.onBlur && $options.onBlur(...args)),
              onKeydown: _cache[3] || (_cache[3] = ($event) => !_ctx.isDisabled && !_ctx.isReadonly && $options.onKeydown($event)),
              id: `w-select--${_ctx._.uid}`,
              placeholder: !_ctx.$slots.selection && $props.placeholder || null,
              disabled: _ctx.isDisabled || null,
              readonly: "",
              "aria-readonly": "true",
              required: _ctx.required || null,
              tabindex: _ctx.tabindex || null,
              autocomplete: "off"
            }, null, 40, _hoisted_4$5),
            (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.inputValue.length ? _ctx.inputValue : [{}], (val, i) => {
              return openBlock(), createElementBlock("input", {
                key: i,
                type: "hidden",
                value: val.value || "",
                name: _ctx.inputName + ($props.multiple ? "[]" : "")
              }, null, 8, _hoisted_5$4);
            }), 128)),
            $props.labelPosition === "inside" && $options.showLabelInside ? (openBlock(), createElementBlock(Fragment, { key: 2 }, [
              _ctx.$slots.default || $props.label ? (openBlock(), createElementBlock("label", {
                key: 0,
                class: normalizeClass(["w-select__label w-select__label--inside w-form-el-shakable", _ctx.labelClasses]),
                for: `w-select--${_ctx._.uid}`
              }, [
                renderSlot(_ctx.$slots, "default", {}, () => [
                  createTextVNode(toDisplayString($props.label), 1)
                ])
              ], 10, _hoisted_6$2)) : createCommentVNode("", true)
            ], 64)) : createCommentVNode("", true),
            $props.innerIconRight ? (openBlock(), createBlock(_component_w_icon, {
              key: 3,
              class: "w-select__icon w-select__icon--inner-right",
              tag: "label",
              onClick: _cache[4] || (_cache[4] = ($event) => _ctx.$emit("click:inner-icon-right", $event))
            }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString($props.innerIconRight), 1)
              ]),
              _: 1
            })) : createCommentVNode("", true)
          ], 10, _hoisted_2$6)
        ]),
        default: withCtx(() => [
          createVNode(_component_w_list, {
            ref: "w-list",
            "model-value": _ctx.inputValue,
            "onUpdate:modelValue": $options.onInput,
            onItemClick: _cache[6] || (_cache[6] = ($event) => _ctx.$emit("item-click", $event)),
            onItemSelect: $options.onListItemSelect,
            "onKeydown:enter": _cache[7] || (_cache[7] = ($event) => $props.noUnselect && !$props.multiple && $options.closeMenu()),
            "onKeydown:escape": $options.closeMenu,
            items: $options.selectItems,
            multiple: $props.multiple,
            "arrows-navigation": "",
            "return-object": "",
            "add-ids": `w-select-menu--${_ctx._.uid}`,
            "no-unselect": $props.noUnselect,
            "selection-color": $props.selectionColor,
            "item-color-key": $props.itemColorKey,
            role: "listbox",
            tabindex: "-1"
          }, createSlots({ _: 2 }, [
            renderList($props.items.length, (i) => {
              return {
                name: `item.${i}`,
                fn: withCtx(({ item, selected, index: index2 }) => [
                  _ctx.$slots[`item.${i}`] && _ctx.$slots[`item.${i}`](item, selected, index2) ? renderSlot(_ctx.$slots, `item.${i}`, {
                    key: 0,
                    item,
                    selected,
                    index: index2
                  }, () => [
                    createTextVNode(toDisplayString(item[$props.itemLabelKey]), 1)
                  ]) : renderSlot(_ctx.$slots, "item", {
                    key: 1,
                    item,
                    selected,
                    index: index2
                  }, () => [
                    createTextVNode(toDisplayString(item[$props.itemLabelKey]), 1)
                  ])
                ])
              };
            })
          ]), 1032, ["model-value", "onUpdate:modelValue", "onItemSelect", "onKeydown:escape", "items", "multiple", "add-ids", "no-unselect", "selection-color", "item-color-key"])
        ]),
        _: 3
      }, 16, ["modelValue", "menu-class", "append-to"]),
      $props.labelPosition === "right" ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
        _ctx.$slots.default || $props.label ? (openBlock(), createElementBlock("label", {
          key: 0,
          class: normalizeClass(["w-select__label w-select__label--right w-form-el-shakable", _ctx.labelClasses]),
          for: `w-select--${_ctx._.uid}`
        }, [
          renderSlot(_ctx.$slots, "default", {}, () => [
            createTextVNode(toDisplayString($props.label), 1)
          ])
        ], 10, _hoisted_7$2)) : createCommentVNode("", true)
      ], 64)) : createCommentVNode("", true)
    ]),
    _: 3
  }, 16, ["valid", "onReset", "wrap", "class"]);
}
var wSelect_vue_vue_type_style_index_0_lang = "";
const _sfc_main$k = {
  name: "w-select",
  mixins: [FormElementMixin],
  props: {
    items: { type: Array, required: true },
    modelValue: {},
    multiple: { type: Boolean },
    placeholder: { type: String },
    label: { type: String },
    labelPosition: { type: String, default: "inside" },
    innerIconLeft: { type: String },
    innerIconRight: { type: String, default: "wi-triangle-down" },
    staticLabel: { type: Boolean },
    itemLabelKey: { type: String, default: "label" },
    itemColorKey: { type: String, default: "color" },
    itemValueKey: { type: String, default: "value" },
    itemClass: { type: String },
    menuClass: { type: String },
    color: { type: String, default: "primary" },
    bgColor: { type: String },
    labelColor: { type: String, default: "primary" },
    selectionColor: { type: String, default: "primary" },
    outline: { type: Boolean },
    round: { type: Boolean },
    shadow: { type: Boolean },
    tile: { type: Boolean },
    dark: { type: Boolean },
    returnObject: { type: Boolean },
    noUnselect: { type: Boolean },
    menuProps: { type: Object }
  },
  emits: ["input", "update:modelValue", "focus", "blur", "item-click", "item-select", "click:inner-icon-left", "click:inner-icon-right"],
  data: () => ({
    inputValue: [],
    showMenu: false,
    menuMinWidth: 0,
    isFocused: false,
    selectionWrapRef: void 0
  }),
  computed: {
    selectItems() {
      return this.items.map((item, i) => {
        const obj = { ...item };
        obj.value = obj[this.itemValueKey] === void 0 ? obj[this.itemLabelKey] || i : obj[this.itemValueKey];
        obj.index = i;
        return obj;
      });
    },
    hasValue() {
      return Array.isArray(this.inputValue) ? this.inputValue.length : this.inputValue !== null;
    },
    hasLabel() {
      return this.label || this.$slots.default;
    },
    showLabelInside() {
      return !this.staticLabel || !this.hasValue && !this.placeholder;
    },
    selectionString() {
      return this.inputValue && this.inputValue.map(
        (item) => item[this.itemValueKey] !== void 0 ? item[this.itemLabelKey] : item[this.itemLabelKey] !== void 0 ? item[this.itemLabelKey] : item
      ).join(", ");
    },
    classes() {
      return {
        "w-select": true,
        "w-select--disabled": this.isDisabled,
        "w-select--readonly": this.isReadonly,
        [`w-select--${this.hasValue ? "filled" : "empty"}`]: true,
        "w-select--focused": (this.isFocused || this.showMenu) && !this.isReadonly,
        "w-select--dark": this.dark,
        "w-select--floating-label": this.hasLabel && this.labelPosition === "inside" && !this.staticLabel,
        "w-select--no-padding": !this.outline && !this.bgColor && !this.shadow && !this.round,
        "w-select--has-placeholder": this.placeholder,
        "w-select--inner-icon-left": this.innerIconLeft,
        "w-select--inner-icon-right": this.innerIconRight,
        "w-select--open": this.showMenu
      };
    },
    inputWrapClasses() {
      return {
        [this.valid === false ? "error" : this.color]: this.color || this.valid === false,
        [`${this.bgColor}--bg`]: this.bgColor,
        "w-select__selection-wrap--round": this.round,
        "w-select__selection-wrap--tile": this.tile,
        "w-select__selection-wrap--box": this.outline || this.bgColor || this.shadow,
        "w-select__selection-wrap--underline": !this.outline,
        "w-select__selection-wrap--shadow": this.shadow,
        "w-select__selection-wrap--no-padding": !this.outline && !this.bgColor && !this.shadow && !this.round
      };
    }
  },
  methods: {
    onFocus(e) {
      this.isFocused = true;
      this.$emit("focus", e);
    },
    onBlur(e) {
      this.isFocused = false;
      this.$emit("blur", e);
    },
    onKeydown(e) {
      if ([13, 27, 38, 40].includes(e.keyCode))
        e.preventDefault();
      if (e.keyCode === 27)
        this.closeMenu();
      else if (e.keyCode === 13)
        this.openMenu();
      else if ([38, 40].includes(e.keyCode)) {
        if (this.multiple)
          this.openMenu();
        else {
          let { index: index2 } = this.inputValue[0] || {};
          const items = this.selectItems;
          if (index2 === void 0)
            index2 = e.keyCode === 38 ? items.length - 1 : 0;
          else {
            const direction = e.keyCode === 38 ? -1 : 1;
            index2 = (index2 + items.length + direction) % items.length;
          }
          this.onInput(items[index2]);
        }
      }
    },
    onInput(items) {
      this.inputValue = items === null ? [] : this.multiple ? items : [items];
      items = this.inputValue.map((item) => this.returnObject ? this.items[item.index] : item.value);
      const selection = this.multiple ? items : items[0];
      this.$emit("update:modelValue", selection);
      this.$emit("input", selection);
    },
    onListItemSelect(e) {
      this.$emit("item-select", e);
      if (!this.multiple)
        this.closeMenu();
    },
    onReset() {
      this.inputValue = [];
      const selection = this.multiple ? [] : null;
      this.$emit("update:modelValue", selection);
      this.$emit("input", selection);
    },
    checkSelection(items) {
      items = Array.isArray(items) ? items : items ? [items] : [];
      const allValues = this.selectItems.map((item) => item.value);
      return items.map((item) => {
        let value = item;
        if (typeof item === "object") {
          value = item[this.itemValueKey] !== void 0 ? item[this.itemValueKey] : item[this.itemLabelKey] !== void 0 ? item[this.itemLabelKey] : item;
        }
        return this.selectItems[allValues.indexOf(value)];
      }).filter((item) => item !== void 0);
    },
    openMenu() {
      this.showMenu = true;
      setTimeout(() => {
        var _a;
        const itemIndex = this.inputValue.length ? this.inputValue[0].index : 0;
        (_a = this.$refs["w-list"].$el.querySelector(`#w-select-menu--${this._.uid}_item-${itemIndex + 1}`)) == null ? void 0 : _a.focus();
      }, 100);
    },
    closeMenu() {
      if ((this.menuProps || {}).hideOnMenuClick === false)
        return;
      this.showMenu = false;
      setTimeout(() => this.$refs["selection-input"].focus(), 50);
    }
  },
  created() {
    this.inputValue = this.checkSelection(this.modelValue);
  },
  watch: {
    modelValue(value) {
      if (value !== this.inputValue)
        this.inputValue = this.checkSelection(value);
    },
    items() {
      this.inputValue = this.checkSelection(this.modelValue);
    }
  }
};
var wSelect = /* @__PURE__ */ _export_sfc(_sfc_main$k, [["render", render$k]]);
const _hoisted_1$9 = ["for"];
const _hoisted_2$5 = ["for", "innerHTML"];
const _hoisted_3$5 = { class: "w-slider__track-wrap" };
const _hoisted_4$4 = ["aria-valuemin", "aria-valuemax", "aria-valuenow", "aria-readonly"];
const _hoisted_5$3 = ["id", "name", "model-value", "disabled", "readonly", "aria-readonly", "tabindex"];
const _hoisted_6$1 = ["for"];
const _hoisted_7$1 = { key: 0 };
const _hoisted_8$1 = {
  key: 0,
  class: "w-slider__step-labels"
};
const _hoisted_9$1 = ["onClick"];
const _hoisted_10$1 = ["for"];
const _hoisted_11$1 = ["for", "innerHTML"];
function render$j(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(resolveDynamicComponent(_ctx.formRegister ? "w-form-element" : "div"), mergeProps({ ref: "formEl" }, _ctx.formRegister && { validators: _ctx.validators, inputValue: _ctx.rangeValueScaled, disabled: _ctx.isDisabled, readonly: _ctx.isReadonly }, {
    valid: _ctx.valid,
    "onUpdate:valid": _cache[8] || (_cache[8] = ($event) => _ctx.valid = $event),
    onReset: _cache[9] || (_cache[9] = ($event) => {
      _ctx.rangeValuePercent = 0;
      $options.updateRangeValueScaled();
    }),
    wrap: _ctx.formRegister || null,
    class: $options.wrapperClasses
  }), {
    default: withCtx(() => [
      _ctx.$slots["label-left"] ? (openBlock(), createElementBlock("label", {
        key: 0,
        class: normalizeClass(["w-slider__label w-slider__label--left w-form-el-shakable", _ctx.labelClasses]),
        for: `button--${_ctx._.uid}`
      }, [
        renderSlot(_ctx.$slots, "label-left")
      ], 10, _hoisted_1$9)) : $props.labelLeft ? (openBlock(), createElementBlock("label", {
        key: 1,
        class: normalizeClass(["w-slider__label w-slider__label--left w-form-el-shakable", _ctx.labelClasses]),
        for: `button--${_ctx._.uid}`,
        innerHTML: $props.labelLeft
      }, null, 10, _hoisted_2$5)) : createCommentVNode("", true),
      createElementVNode("div", _hoisted_3$5, [
        createElementVNode("div", {
          class: normalizeClass(["w-slider__track", $options.trackClasses]),
          ref: "track",
          onMousedown: _cache[4] || (_cache[4] = (...args) => $options.onTrackMouseDown && $options.onTrackMouseDown(...args)),
          onTouchstart: _cache[5] || (_cache[5] = (...args) => $options.onTrackMouseDown && $options.onTrackMouseDown(...args)),
          role: "slider",
          "aria-label": "Slider",
          "aria-valuemin": $options.minVal,
          "aria-valuemax": $options.maxVal,
          "aria-valuenow": _ctx.rangeValueScaled,
          "aria-readonly": _ctx.isReadonly ? "true" : "false",
          "aria-orientation": "horizontal"
        }, [
          createElementVNode("div", {
            class: normalizeClass(["w-slider__range", $options.rangeClasses]),
            style: normalizeStyle($options.rangeStyles)
          }, null, 6),
          createElementVNode("div", {
            class: "w-slider__thumb",
            style: normalizeStyle($options.thumbStyles)
          }, [
            createElementVNode("button", {
              class: normalizeClass(["w-slider__thumb-button", [$props.color]]),
              ref: "thumb",
              id: `button--${_ctx._.uid}`,
              name: _ctx.inputName,
              "model-value": _ctx.rangeValueScaled,
              disabled: _ctx.isDisabled || null,
              readonly: _ctx.isReadonly || null,
              "aria-readonly": _ctx.isReadonly ? "true" : "false",
              tabindex: _ctx.isDisabled || _ctx.isReadonly ? -1 : null,
              onKeydown: [
                _cache[0] || (_cache[0] = withKeys(($event) => $options.onKeyDown($event, -1), ["left"])),
                _cache[1] || (_cache[1] = withKeys(($event) => $options.onKeyDown($event, 1), ["right"]))
              ],
              onFocus: _cache[2] || (_cache[2] = ($event) => _ctx.$emit("focus", $event)),
              onClick: _cache[3] || (_cache[3] = withModifiers(() => {
              }, ["prevent"]))
            }, null, 42, _hoisted_5$3),
            $props.thumbLabel ? (openBlock(), createElementBlock("label", {
              key: 0,
              class: normalizeClass(["w-slider__thumb-label", $options.thumbClasses]),
              for: `button--${_ctx._.uid}`
            }, [
              $props.thumbLabel === "droplet" ? (openBlock(), createElementBlock("div", _hoisted_7$1, [
                renderSlot(_ctx.$slots, "label", { value: _ctx.rangeValueScaled }, () => [
                  createTextVNode(toDisplayString(~~_ctx.rangeValueScaled), 1)
                ])
              ])) : renderSlot(_ctx.$slots, "label", {
                key: 1,
                value: _ctx.rangeValueScaled
              }, () => [
                createTextVNode(toDisplayString(~~_ctx.rangeValueScaled), 1)
              ])
            ], 10, _hoisted_6$1)) : createCommentVNode("", true)
          ], 4)
        ], 42, _hoisted_4$4),
        $props.stepLabels && $props.step ? (openBlock(), createElementBlock("div", _hoisted_8$1, [
          createElementVNode("div", {
            class: "w-slider__step-label",
            onClick: _cache[6] || (_cache[6] = ($event) => $options.onStepLabelClick(0))
          }, toDisplayString(this.minVal), 1),
          (openBlock(true), createElementBlock(Fragment, null, renderList(~~$options.numberOfSteps, (currStep) => {
            return openBlock(), createElementBlock("div", {
              class: "w-slider__step-label",
              key: currStep,
              onClick: ($event) => $options.onStepLabelClick(currStep * (100 / $options.numberOfSteps)),
              style: normalizeStyle(`left: ${currStep * (100 / $options.numberOfSteps)}%`)
            }, toDisplayString($options.percentToScaled(currStep * (100 / $options.numberOfSteps))), 13, _hoisted_9$1);
          }), 128)),
          ~~$options.numberOfSteps !== $options.numberOfSteps ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: "w-slider__step-label",
            onClick: _cache[7] || (_cache[7] = ($event) => $options.onStepLabelClick(100)),
            style: { "left": "100%" }
          }, toDisplayString(this.maxVal), 1)) : createCommentVNode("", true)
        ])) : createCommentVNode("", true)
      ]),
      _ctx.$slots["label-right"] ? (openBlock(), createElementBlock("label", {
        key: 2,
        class: normalizeClass(["w-slider__label w-slider__label--right w-form-el-shakable", _ctx.labelClasses]),
        for: `button--${_ctx._.uid}`
      }, [
        renderSlot(_ctx.$slots, "label-right")
      ], 10, _hoisted_10$1)) : $props.labelRight ? (openBlock(), createElementBlock("label", {
        key: 3,
        class: normalizeClass(["w-slider__label w-slider__label--right w-form-el-shakable", _ctx.labelClasses]),
        for: `button--${_ctx._.uid}`,
        innerHTML: $props.labelRight
      }, null, 10, _hoisted_11$1)) : createCommentVNode("", true)
    ]),
    _: 3
  }, 16, ["valid", "wrap", "class"]);
}
var wSlider_vue_vue_type_style_index_0_lang = "";
const _sfc_main$j = {
  name: "w-slider",
  mixins: [FormElementMixin],
  props: {
    modelValue: { type: Number, default: 0 },
    color: { type: String, default: "primary" },
    bgColor: { type: String },
    labelColor: { type: String, default: "primary" },
    stepLabels: { type: [Boolean, Array] },
    thumbLabel: { type: [Boolean, String] },
    thumbLabelClass: { type: String },
    trackClass: { type: String },
    rangeClass: { type: String },
    min: { type: [Number, String], default: 0 },
    max: { type: [Number, String], default: 100 },
    step: { type: [Number, String] },
    labelLeft: { type: String },
    labelRight: { type: String }
  },
  emits: ["input", "update:modelValue", "focus"],
  data: () => ({
    track: {
      el: null,
      left: 0,
      width: 0
    },
    dragging: false,
    rangeValuePercent: 0,
    rangeValueScaled: 0
  }),
  computed: {
    minVal() {
      return parseFloat(this.min);
    },
    maxVal() {
      return parseFloat(this.max);
    },
    stepValPercent() {
      return Math.min(parseFloat(this.step), this.scaledRange) / this.scaledRange * 100;
    },
    scaledRange() {
      return this.maxVal - this.minVal;
    },
    numberOfSteps() {
      return 100 / this.stepValPercent;
    },
    rangeStyles() {
      return {
        width: `${this.rangeValuePercent}%`
      };
    },
    thumbStyles() {
      return {
        left: `${this.rangeValuePercent}%`
      };
    },
    rangeClasses() {
      return {
        [`${this.color}--bg`]: this.color,
        [this.rangeClass]: this.rangeClass || null
      };
    },
    trackClasses() {
      return {
        [`${this.bgColor}--bg`]: this.bgColor,
        [this.trackClass]: this.trackClass || null
      };
    },
    thumbClasses() {
      return {
        [this.thumbLabelClass]: this.thumbLabelClass || null,
        "w-slider__thumb-label--droplet": this.thumbLabel === "droplet"
      };
    },
    wrapperClasses() {
      return {
        "w-slider": true,
        "w-slider--dragging": this.dragging,
        "w-slider--disabled": this.isDisabled,
        "w-slider--readonly": this.isReadonly,
        "w-slider--has-step-labels": this.step && this.stepLabels
      };
    }
  },
  methods: {
    scaledToPercent(value) {
      return Math.max(0, Math.min((value - this.minVal) / this.scaledRange * 100, 100));
    },
    percentToScaled(value) {
      return Math.round((value / 100 * this.scaledRange + this.minVal) * 100) / 100;
    },
    onTrackMouseDown(e) {
      if (this.isDisabled || this.isReadonly)
        return;
      if ("ontouchstart" in window && e.type === "mousedown")
        return;
      const { left, width } = this.track.el.getBoundingClientRect();
      this.track.width = width;
      this.track.left = left;
      this.dragging = true;
      this.updateRange(e.type === "touchstart" ? e.touches[0].clientX : e.clientX);
      document.addEventListener(e.type === "touchstart" ? "touchmove" : "mousemove", this.onDrag);
      document.addEventListener(e.type === "touchstart" ? "touchend" : "mouseup", this.onMouseUp, { once: true });
    },
    onDrag(e) {
      this.updateRange(e.type === "touchmove" ? e.touches[0].clientX : e.clientX);
    },
    onMouseUp(e) {
      this.dragging = false;
      document.removeEventListener(e.type === "touchend" ? "touchmove" : "mousemove", this.onDrag);
      if (this.$refs.thumb)
        this.$refs.thumb.focus();
    },
    onStepLabelClick(step) {
      this.rangeValuePercent = step;
      this.updateRangeValueScaled();
    },
    onKeyDown(e, direction) {
      if (this.isDisabled || this.isReadonly)
        return;
      this.rangeValuePercent += direction * (e.shiftKey ? 5 : 1) * (this.stepValPercent || 1);
      this.rangeValuePercent = Math.max(0, Math.min(this.rangeValuePercent, 100));
      this.updateRangeValueScaled();
    },
    updateRange(cursorPositionX) {
      this.rangeValuePercent = Math.max(0, Math.min((cursorPositionX - this.track.left) / this.track.width * 100, 100));
      if (this.step) {
        const valuePlusHalfStep = this.rangeValuePercent + this.stepValPercent / 2;
        this.rangeValuePercent = valuePlusHalfStep - valuePlusHalfStep % this.stepValPercent;
      }
      this.updateRangeValueScaled();
    },
    updateRangeValueScaled() {
      this.rangeValueScaled = this.percentToScaled(this.rangeValuePercent);
      this.$emit("update:modelValue", this.rangeValueScaled);
      this.$emit("input", this.rangeValueScaled);
    }
  },
  beforeMount() {
    this.$nextTick(() => {
      this.track.el = this.$refs.track;
      this.rangeValueScaled = this.modelValue;
      this.rangeValuePercent = this.scaledToPercent(this.modelValue);
    });
  },
  watch: {
    modelValue(value) {
      if (this.rangeValueScaled !== value) {
        this.rangeValueScaled = value;
        this.rangeValuePercent = this.scaledToPercent(value);
      }
    }
  }
};
var wSlider = /* @__PURE__ */ _export_sfc(_sfc_main$j, [["render", render$j]]);
const _hoisted_1$8 = { key: 0 };
function render$i(_ctx, _cache, $props, $setup, $data, $options) {
  return $props.modelValue || $props.modelValue === void 0 ? (openBlock(), createElementBlock("div", {
    key: 0,
    class: normalizeClass(["w-spinner", $options.classes]),
    style: normalizeStyle($options.styles)
  }, [
    $options.isThreeDots ? (openBlock(), createElementBlock("span", _hoisted_1$8)) : createCommentVNode("", true)
  ], 6)) : createCommentVNode("", true);
}
var wSpinner_vue_vue_type_style_index_0_lang = "";
const _sfc_main$i = {
  name: "w-spinner",
  props: {
    modelValue: {},
    color: { type: String, default: "primary" },
    xs: { type: Boolean },
    sm: { type: Boolean },
    md: { type: Boolean },
    lg: { type: Boolean },
    xl: { type: Boolean },
    size: { type: [Number, String] },
    bounce: { type: Boolean },
    fade: { type: Boolean }
  },
  emits: [],
  computed: {
    isThreeDots() {
      return !this.bounce && !this.fade;
    },
    forcedSize() {
      return this.size && (!isNaN(this.size) ? `${this.size}px` : this.size);
    },
    presetSize() {
      return this.xs && "xs" || this.sm && "sm" || this.md && "md" || this.lg && "lg" || this.xl && "xl" || null;
    },
    styles() {
      return this.forcedSize && `font-size: ${this.forcedSize}` || null;
    },
    classes() {
      return {
        [this.color]: this.color,
        [`size--${this.presetSize}`]: this.presetSize && !this.forcedSize,
        "w-spinner--bounce": this.bounce,
        "w-spinner--fade": this.fade,
        "w-spinner--three-dots": this.isThreeDots
      };
    }
  }
};
var wSpinner = /* @__PURE__ */ _export_sfc(_sfc_main$i, [["render", render$i]]);
const _hoisted_1$7 = { class: "w-steps" };
function render$h(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$7);
}
var wSteps_vue_vue_type_style_index_0_lang = "";
const _sfc_main$h = {
  name: "w-steps",
  props: {},
  emits: [],
  data: () => ({})
};
var wSteps = /* @__PURE__ */ _export_sfc(_sfc_main$h, [["render", render$h]]);
const _hoisted_1$6 = ["id", "name", "checked", "disabled", "readonly", "aria-readonly", "required", "tabindex", "aria-checked"];
const _hoisted_2$4 = ["for"];
const _hoisted_3$4 = {
  key: 0,
  class: "w-switch__track"
};
const _hoisted_4$3 = {
  key: 1,
  class: "w-switch__thumb"
};
const _hoisted_5$2 = ["for"];
function render$g(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(resolveDynamicComponent(_ctx.formRegister ? "w-form-element" : "div"), mergeProps({ ref: "formEl" }, _ctx.formRegister && { validators: _ctx.validators, inputValue: $data.isOn, disabled: _ctx.isDisabled, readonly: _ctx.isReadonly }, {
    valid: _ctx.valid,
    "onUpdate:valid": _cache[3] || (_cache[3] = ($event) => _ctx.valid = $event),
    onReset: _cache[4] || (_cache[4] = ($event) => {
      _ctx.$emit("update:modelValue", $data.isOn = null);
      _ctx.$emit("input", null);
    }),
    class: $options.classes
  }), {
    default: withCtx(() => [
      createElementVNode("input", {
        ref: "input",
        id: `w-switch--${_ctx._.uid}`,
        type: "checkbox",
        name: _ctx.inputName,
        checked: $data.isOn,
        disabled: _ctx.isDisabled || _ctx.isReadonly || null,
        readonly: _ctx.isReadonly || null,
        "aria-readonly": _ctx.isReadonly ? "true" : "false",
        required: _ctx.required || null,
        tabindex: _ctx.tabindex || null,
        onChange: _cache[0] || (_cache[0] = ($event) => $options.onInput()),
        onFocus: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("focus", $event)),
        "aria-checked": $data.isOn || "false",
        role: "switch"
      }, null, 40, _hoisted_1$6),
      $options.hasLabel && $props.labelOnLeft ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
        _ctx.$slots.default || $props.label ? (openBlock(), createElementBlock("label", {
          key: 0,
          class: normalizeClass(["w-switch__label w-switch__label--left w-form-el-shakable", _ctx.labelClasses]),
          for: `w-switch--${_ctx._.uid}`
        }, [
          renderSlot(_ctx.$slots, "default", {}, () => [
            createTextVNode(toDisplayString($props.label), 1)
          ])
        ], 10, _hoisted_2$4)) : createCommentVNode("", true)
      ], 64)) : createCommentVNode("", true),
      createElementVNode("div", mergeProps({
        class: "w-switch__input",
        onClick: _cache[2] || (_cache[2] = ($event) => {
          _ctx.$refs.input.focus();
          _ctx.$refs.input.click();
        })
      }, toHandlers(_ctx.$attrs, true), { class: $options.inputClasses }), [
        _ctx.$slots.track ? (openBlock(), createElementBlock("div", _hoisted_3$4, [
          renderSlot(_ctx.$slots, "track")
        ])) : createCommentVNode("", true),
        _ctx.$slots.thumb ? (openBlock(), createElementBlock("div", _hoisted_4$3, [
          renderSlot(_ctx.$slots, "thumb")
        ])) : createCommentVNode("", true)
      ], 16),
      $options.hasLabel && !$props.labelOnLeft ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
        _ctx.$slots.default || $props.label ? (openBlock(), createElementBlock("label", {
          key: 0,
          class: normalizeClass(["w-switch__label w-switch__label--right w-form-el-shakable", _ctx.labelClasses]),
          for: `w-switch--${_ctx._.uid}`
        }, [
          renderSlot(_ctx.$slots, "default", {}, () => [
            createTextVNode(toDisplayString($props.label), 1)
          ])
        ], 10, _hoisted_5$2)) : createCommentVNode("", true)
      ], 64)) : createCommentVNode("", true)
    ]),
    _: 3
  }, 16, ["valid", "class"]);
}
var wSwitch_vue_vue_type_style_index_0_lang = "";
const _sfc_main$g = {
  name: "w-switch",
  mixins: [FormElementMixin],
  props: {
    modelValue: { default: false },
    label: { type: String, default: "" },
    labelOnLeft: { type: Boolean },
    color: { type: String, default: "primary" },
    labelColor: { type: String, default: "primary" },
    thin: { type: Boolean },
    noRipple: { type: Boolean }
  },
  emits: ["input", "update:modelValue", "focus"],
  data() {
    return {
      isOn: this.modelValue,
      ripple: {
        start: false,
        end: false,
        timeout: null
      }
    };
  },
  computed: {
    hasLabel() {
      return this.label || this.$slots.default;
    },
    classes() {
      return {
        [`w-switch w-switch--${this.isOn ? "on" : "off"}`]: true,
        "w-switch--thin": this.thin,
        "w-switch--disabled": this.isDisabled,
        "w-switch--readonly": this.isReadonly,
        "w-switch--ripple": this.ripple.start,
        "w-switch--custom-thumb": this.$slots.thumb,
        "w-switch--custom-track": this.$slots.track,
        "w-switch--rippled": this.ripple.end
      };
    },
    inputClasses() {
      const side = this.hasLabel && this.labelOnLeft ? "l" : "r";
      return [
        this.color,
        this.hasLabel ? this.thin ? `m${side}3` : `m${side}2` : ""
      ];
    }
  },
  methods: {
    onInput() {
      this.isOn = !this.isOn;
      this.$emit("update:modelValue", this.isOn);
      this.$emit("input", this.isOn);
      if (!this.noRipple) {
        if (this.isOn) {
          this.ripple.start = true;
          this.ripple.timeout = setTimeout(() => {
            this.ripple.start = false;
            this.ripple.end = true;
            setTimeout(() => this.ripple.end = false, 100);
          }, 700);
        } else {
          this.ripple.start = false;
          clearTimeout(this.ripple.timeout);
        }
      }
    }
  },
  watch: {
    modelValue(value) {
      this.isOn = value;
    }
  }
};
var wSwitch = /* @__PURE__ */ _export_sfc(_sfc_main$g, [["render", render$g]]);
const _hoisted_1$5 = { class: "w-tabs__content" };
function render$f(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$5, [
    renderSlot(_ctx.$slots, "default", { item: $props.item })
  ]);
}
const _sfc_main$f = {
  props: { item: Object }
};
var TabContent = /* @__PURE__ */ _export_sfc(_sfc_main$f, [["render", render$f]]);
const _hoisted_1$4 = ["onClick", "onFocus", "tabindex", "onKeypress", "aria-selected"];
const _hoisted_2$3 = ["innerHTML"];
const _hoisted_3$3 = {
  key: 0,
  class: "w-tabs__bar-extra"
};
const _hoisted_4$2 = {
  key: 0,
  class: "w-tabs__content-wrap"
};
const _hoisted_5$1 = ["innerHTML"];
function render$e(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_tab_content = resolveComponent("tab-content");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["w-tabs", $options.tabsClasses])
  }, [
    createElementVNode("div", {
      class: normalizeClass(["w-tabs__bar", $options.tabsBarClasses]),
      ref: "tabs-bar"
    }, [
      (openBlock(true), createElementBlock(Fragment, null, renderList($options.tabsItems, (item, i) => {
        return openBlock(), createElementBlock("div", {
          class: normalizeClass(["w-tabs__bar-item", $options.barItemClasses(item)]),
          key: i,
          onClick: ($event) => !item._disabled && $options.openTab(item),
          onFocus: ($event) => _ctx.$emit("focus", $options.getOriginalItem(item)),
          tabindex: !item._disabled && 0,
          onKeypress: withKeys(($event) => !item._disabled && $options.openTab(item), ["enter"]),
          "aria-selected": item._index === _ctx.activeTabIndex ? "true" : "false",
          role: "tab"
        }, [
          _ctx.$slots[`item-title.${item.id || i + 1}`] ? renderSlot(_ctx.$slots, `item-title.${item.id || i + 1}`, {
            key: 0,
            item: $options.getOriginalItem(item),
            index: i + 1,
            active: item._index === _ctx.activeTabIndex
          }) : renderSlot(_ctx.$slots, "item-title", {
            key: 1,
            item: $options.getOriginalItem(item),
            index: i + 1,
            active: item._index === _ctx.activeTabIndex
          }, () => [
            createElementVNode("div", {
              innerHTML: item[$props.itemTitleKey]
            }, null, 8, _hoisted_2$3)
          ])
        ], 42, _hoisted_1$4);
      }), 128)),
      _ctx.$slots["tabs-bar-extra"] ? (openBlock(), createElementBlock("div", _hoisted_3$3, [
        renderSlot(_ctx.$slots, "tabs-bar-extra")
      ])) : createCommentVNode("", true),
      !$props.noSlider && !$props.card ? (openBlock(), createElementBlock("div", {
        key: 1,
        class: normalizeClass(["w-tabs__slider", $props.sliderColor]),
        style: normalizeStyle($options.sliderStyles)
      }, null, 6)) : createCommentVNode("", true)
    ], 2),
    $options.tabsItems.length ? (openBlock(), createElementBlock("div", _hoisted_4$2, [
      createVNode(Transition, {
        name: $options.transitionName,
        mode: $options.transitionMode
      }, {
        default: withCtx(() => [
          (openBlock(), createBlock(KeepAlive, null, [
            (openBlock(), createBlock(_component_tab_content, {
              key: $options.activeTab._index,
              item: $options.activeTab,
              class: normalizeClass($props.contentClass)
            }, {
              default: withCtx(({ item }) => [
                _ctx.$slots[`item-content.${item._index + 1}`] ? renderSlot(_ctx.$slots, `item-content.${item._index + 1}`, {
                  key: 0,
                  item: $options.getOriginalItem(item),
                  index: item._index + 1,
                  active: item._index === $options.activeTab._index
                }) : renderSlot(_ctx.$slots, "item-content", {
                  key: 1,
                  item: $options.getOriginalItem(item),
                  index: item._index + 1,
                  active: item._index === $options.activeTab._index
                }, () => [
                  item[$props.itemContentKey] ? (openBlock(), createElementBlock("div", {
                    key: 0,
                    innerHTML: item[$props.itemContentKey]
                  }, null, 8, _hoisted_5$1)) : createCommentVNode("", true)
                ])
              ]),
              _: 3
            }, 8, ["item", "class"]))
          ], 1024))
        ]),
        _: 3
      }, 8, ["name", "mode"])
    ])) : createCommentVNode("", true)
  ], 2);
}
var index_vue_vue_type_style_index_0_lang = "";
const _sfc_main$e = {
  name: "w-tabs",
  props: {
    modelValue: { type: [Number, String] },
    color: { type: String },
    bgColor: { type: String },
    items: { type: [Array, Number] },
    itemTitleKey: { type: String, default: "title" },
    itemContentKey: { type: String, default: "content" },
    titleClass: { type: String },
    activeClass: { type: String, default: "primary" },
    noSlider: { type: Boolean },
    pillSlider: { type: Boolean },
    sliderColor: { type: String, default: "primary" },
    contentClass: { type: String },
    transition: { type: [String, Boolean], default: "" },
    fillBar: { type: Boolean },
    center: { type: Boolean },
    right: { type: Boolean },
    card: { type: Boolean }
  },
  components: { TabContent },
  emits: ["input", "update:modelValue", "focus"],
  data: () => ({
    activeTabEl: null,
    activeTabIndex: 0,
    prevTabIndex: -1,
    slider: {
      left: 0,
      width: 0
    },
    init: true
  }),
  computed: {
    transitionName() {
      if (this.transition === false)
        return "";
      return this.transition || `w-tabs-slide-${this.direction}`;
    },
    transitionMode() {
      return ["w-tabs-slide-left", "w-tabs-slide-right"].includes(this.transitionName) ? "" : "out-in";
    },
    direction() {
      return this.activeTab._index < this.prevTabIndex ? "right" : "left";
    },
    tabsItems() {
      const items = typeof this.items === "number" ? Array(this.items).fill({}) : this.items;
      return items.map((item, _index) => reactive({
        ...item,
        _index,
        _disabled: !!item.disabled
      }));
    },
    activeTab() {
      return this.tabsItems[this.activeTabIndex] || this.tabsItems[0] || {};
    },
    tabsClasses() {
      return {
        "w-tabs--card": this.card,
        "w-tabs--no-slider": this.noSlider,
        "w-tabs--pill-slider": this.pillSlider,
        "w-tabs--fill-bar": this.fillBar,
        "w-tabs--init": this.init
      };
    },
    tabsBarClasses() {
      return {
        "w-tabs__bar--right": this.right,
        "w-tabs__bar--center": this.center
      };
    },
    sliderStyles() {
      return {
        left: this.slider.left,
        width: this.slider.width
      };
    }
  },
  methods: {
    onResize() {
      this.updateSlider(false);
    },
    barItemClasses(item) {
      const isActive = item._index === this.activeTabIndex;
      return {
        [`${this.bgColor}--bg`]: this.bgColor,
        [this.color]: this.color && !item._disabled && !(this.activeClass && isActive),
        [`w-tabs__bar-item--active ${this.activeClass}`]: isActive,
        "w-tabs__bar-item--disabled": item._disabled,
        [this.titleClass]: this.titleClass
      };
    },
    openTab(item) {
      this.prevTabIndex = this.activeTabIndex;
      this.activeTabIndex = item._index;
      this.$emit("update:modelValue", item._index);
      this.$emit("input", item._index);
      if (!this.noSlider)
        this.$nextTick(this.updateSlider);
    },
    updateSlider(domLookup = true) {
      if (domLookup) {
        const ref = this.$refs["tabs-bar"];
        this.activeTabEl = ref && ref.querySelector(".w-tabs__bar-item--active");
      }
      if (!this.fillBar && this.activeTabEl) {
        const { left, width } = this.activeTabEl.getBoundingClientRect();
        const { left: parentLeft } = this.activeTabEl.parentNode.getBoundingClientRect();
        this.slider.left = `${left - parentLeft + this.activeTabEl.parentNode.scrollLeft}px`;
        this.slider.width = `${width}px`;
      } else {
        this.slider.left = `${this.activeTab._index * 100 / this.tabsItems.length}%`;
        this.slider.width = `${100 / this.tabsItems.length}%`;
      }
    },
    updateActiveTab(index2) {
      if (typeof index2 === "string")
        index2 = ~~index2;
      else if (isNaN(index2) || index2 < 0)
        index2 = 0;
      this.activeTabIndex = index2;
      this.$nextTick(() => {
        const ref = this.$refs["tabs-bar"];
        this.activeTabEl = ref && ref.querySelector(`.w-tabs__bar-item:nth-child(${index2 + 1})`);
        if (this.activeTabEl) {
          this.activeTabEl.scrollIntoView({ behavior: "smooth", block: "nearest", inline: "nearest" });
        }
      });
    },
    getOriginalItem(item) {
      return this.items[item._index];
    }
  },
  beforeMount() {
    this.updateActiveTab(this.modelValue);
    this.$nextTick(() => {
      this.updateSlider();
      setTimeout(() => this.init = false, 0);
    });
    if (!this.noSlider)
      window.addEventListener("resize", this.onResize);
  },
  beforeUnmount() {
    window.removeEventListener("resize", this.onResize);
  },
  watch: {
    modelValue(index2) {
      this.updateActiveTab(index2);
    },
    items() {
      while (this.activeTabIndex > 0 && !this.tabsItems[this.activeTabIndex])
        this.activeTabIndex--;
      if (!this.noSlider)
        this.$nextTick(this.updateSlider);
    },
    fillBar() {
      if (!this.noSlider)
        this.$nextTick(this.updateSlider);
    },
    noSlider(value) {
      if (!value) {
        this.updateSlider();
        window.addEventListener("resize", this.onResize);
      } else
        window.removeEventListener("resize", this.onResize);
    }
  }
};
var index = /* @__PURE__ */ _export_sfc(_sfc_main$e, [["render", render$e]]);
const _hoisted_1$3 = { ref: "colgroup" };
const _hoisted_2$2 = ["width"];
const _hoisted_3$2 = { key: 0 };
const _hoisted_4$1 = ["onClick"];
const _hoisted_5 = /* @__PURE__ */ createTextVNode("wi-arrow-down");
const _hoisted_6 = ["innerHTML"];
const _hoisted_7 = /* @__PURE__ */ createTextVNode("wi-arrow-down");
const _hoisted_8 = {
  key: 0,
  class: "w-table__progress-bar"
};
const _hoisted_9 = ["colspan"];
const _hoisted_10 = { class: "w-table__loading-text" };
const _hoisted_11 = /* @__PURE__ */ createTextVNode("Loading...");
const _hoisted_12 = {
  key: 1,
  class: "no-data"
};
const _hoisted_13 = ["colspan"];
const _hoisted_14 = /* @__PURE__ */ createTextVNode("No data to show.");
const _hoisted_15 = ["onClick"];
const _hoisted_16 = ["data-label"];
const _hoisted_17 = ["data-label"];
const _hoisted_18 = ["innerHTML"];
const _hoisted_19 = {
  key: 2,
  class: "w-table__row w-table__row--expansion"
};
const _hoisted_20 = ["colspan"];
const _hoisted_21 = { key: 0 };
const _hoisted_22 = {
  key: 3,
  class: "w-table__extra-row"
};
const _hoisted_23 = {
  key: 1,
  class: "w-table__footer"
};
const _hoisted_24 = {
  key: 1,
  class: "w-table__row"
};
const _hoisted_25 = ["colspan"];
function render$d(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_w_icon = resolveComponent("w-icon");
  const _component_w_progress = resolveComponent("w-progress");
  const _component_w_transition_expand = resolveComponent("w-transition-expand");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["w-table-wrap", $options.wrapClasses])
  }, [
    createElementVNode("table", {
      class: normalizeClass(["w-table", $options.classes]),
      onMousedown: _cache[1] || (_cache[1] = (...args) => $options.onMouseDown && $options.onMouseDown(...args)),
      onMouseover: _cache[2] || (_cache[2] = (...args) => $options.onMouseOver && $options.onMouseOver(...args)),
      onMouseout: _cache[3] || (_cache[3] = (...args) => $options.onMouseOut && $options.onMouseOut(...args))
    }, [
      createElementVNode("colgroup", _hoisted_1$3, [
        (openBlock(true), createElementBlock(Fragment, null, renderList($props.headers, (header, i) => {
          return openBlock(), createElementBlock("col", {
            class: "w-table__col",
            key: i,
            width: header.width || null
          }, null, 8, _hoisted_2$2);
        }), 128))
      ], 512),
      !$props.noHeaders ? (openBlock(), createElementBlock("thead", _hoisted_3$2, [
        createElementVNode("tr", null, [
          (openBlock(true), createElementBlock(Fragment, null, renderList($props.headers, (header, i) => {
            return openBlock(), createElementBlock("th", {
              class: normalizeClass(["w-table__header", $options.headerClasses(header)]),
              key: i,
              onClick: ($event) => !_ctx.colResizing.dragging && header.sortable !== false && $options.sortTable(header)
            }, [
              header.sortable !== false && header.align === "right" ? (openBlock(), createBlock(_component_w_icon, {
                key: 0,
                class: normalizeClass(["w-table__header-sort", $options.headerSortClasses(header)])
              }, {
                default: withCtx(() => [
                  _hoisted_5
                ]),
                _: 2
              }, 1032, ["class"])) : createCommentVNode("", true),
              header.label ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                _ctx.$slots["header-label"] ? renderSlot(_ctx.$slots, "header-label", {
                  key: 0,
                  header,
                  label: header.label,
                  index: i + 1
                }, () => [
                  createTextVNode(toDisplayString(header.label || ""), 1)
                ]) : (openBlock(), createElementBlock("span", {
                  key: 1,
                  innerHTML: header.label || ""
                }, null, 8, _hoisted_6))
              ], 64)) : createCommentVNode("", true),
              header.sortable !== false && header.align !== "right" ? (openBlock(), createBlock(_component_w_icon, {
                key: 2,
                class: normalizeClass(["w-table__header-sort", $options.headerSortClasses(header)])
              }, {
                default: withCtx(() => [
                  _hoisted_7
                ]),
                _: 2
              }, 1032, ["class"])) : createCommentVNode("", true),
              i < $props.headers.length - 1 && $props.resizableColumns ? (openBlock(), createElementBlock("span", {
                key: 3,
                class: normalizeClass(["w-table__col-resizer", { "w-table__col-resizer--hover": _ctx.colResizing.hover === i, "w-table__col-resizer--active": _ctx.colResizing.columnIndex === i }]),
                onClick: _cache[0] || (_cache[0] = withModifiers(() => {
                }, ["stop"]))
              }, null, 2)) : createCommentVNode("", true)
            ], 10, _hoisted_4$1);
          }), 128))
        ])
      ])) : createCommentVNode("", true),
      createElementVNode("tbody", null, [
        $props.loading ? (openBlock(), createElementBlock("tr", _hoisted_8, [
          createElementVNode("td", {
            colspan: $props.headers.length
          }, [
            createVNode(_component_w_progress, { tile: "" }),
            createElementVNode("div", _hoisted_10, [
              renderSlot(_ctx.$slots, "loading", {}, () => [
                _hoisted_11
              ])
            ])
          ], 8, _hoisted_9)
        ])) : !$options.tableItems.length ? (openBlock(), createElementBlock("tr", _hoisted_12, [
          createElementVNode("td", {
            class: "w-table__cell text-center",
            colspan: $props.headers.length
          }, [
            renderSlot(_ctx.$slots, "no-data", {}, () => [
              _hoisted_14
            ])
          ], 8, _hoisted_13)
        ])) : (openBlock(true), createElementBlock(Fragment, { key: 2 }, renderList($options.sortedItems, (item, i) => {
          return openBlock(), createElementBlock(Fragment, { key: i }, [
            _ctx.$slots.item ? renderSlot(_ctx.$slots, "item", {
              key: 0,
              item,
              index: i + 1,
              select: () => $options.doSelectRow(item, i),
              classes: { "w-table__row": true, "w-table__row--selected": $options.selectedRowsByUid[item._uid] !== void 0, "w-table__row--expanded": $options.expandedRowsByUid[item._uid] !== void 0 }
            }) : (openBlock(), createElementBlock("tr", {
              key: 1,
              class: normalizeClass(["w-table__row", { "w-table__row--selected": $options.selectedRowsByUid[item._uid] !== void 0, "w-table__row--expanded": $options.expandedRowsByUid[item._uid] !== void 0 }]),
              onClick: ($event) => $options.doSelectRow(item, i)
            }, [
              (openBlock(true), createElementBlock(Fragment, null, renderList($props.headers, (header, j) => {
                return openBlock(), createElementBlock(Fragment, null, [
                  _ctx.$slots[`item-cell.${header.key}`] || _ctx.$slots[`item-cell.${j + 1}`] || _ctx.$slots["item-cell"] ? (openBlock(), createElementBlock("td", {
                    class: normalizeClass(["w-table__cell", { [`text-${header.align || "left"}`]: true, "w-table__cell--sticky": header.sticky }]),
                    key: `${j}-a`,
                    "data-label": header.label
                  }, [
                    _ctx.$slots[`item-cell.${header.key}`] ? renderSlot(_ctx.$slots, `item-cell.${header.key}`, {
                      key: 0,
                      header,
                      item,
                      label: item[header.key] || "",
                      index: i + 1
                    }) : _ctx.$slots[`item-cell.${j + 1}`] ? renderSlot(_ctx.$slots, `item-cell.${j + 1}`, {
                      key: 1,
                      header,
                      item,
                      label: item[header.key] || "",
                      index: i + 1
                    }) : _ctx.$slots["item-cell"] ? renderSlot(_ctx.$slots, "item-cell", {
                      key: 2,
                      header,
                      item,
                      label: item[header.key] || "",
                      index: i + 1
                    }) : createCommentVNode("", true),
                    j < $props.headers.length - 1 && $props.resizableColumns ? (openBlock(), createElementBlock("span", {
                      key: 3,
                      class: normalizeClass(["w-table__col-resizer", { "w-table__col-resizer--hover": _ctx.colResizing.hover === j, "w-table__col-resizer--active": _ctx.colResizing.columnIndex === j }])
                    }, null, 2)) : createCommentVNode("", true)
                  ], 10, _hoisted_16)) : (openBlock(), createElementBlock("td", {
                    class: normalizeClass(["w-table__cell", { [`text-${header.align || "left"}`]: true, "w-table__cell--sticky": header.sticky }]),
                    key: `${j}-b`,
                    "data-label": header.label
                  }, [
                    createElementVNode("div", {
                      innerHTML: item[header.key] || ""
                    }, null, 8, _hoisted_18),
                    j < $props.headers.length - 1 && $props.resizableColumns ? (openBlock(), createElementBlock("span", {
                      key: 0,
                      class: normalizeClass(["w-table__col-resizer", { "w-table__col-resizer--hover": _ctx.colResizing.hover === j, "w-table__col-resizer--active": _ctx.colResizing.columnIndex === j }])
                    }, null, 2)) : createCommentVNode("", true)
                  ], 10, _hoisted_17))
                ], 64);
              }), 256))
            ], 10, _hoisted_15)),
            $options.expandedRowsByUid[item._uid] ? (openBlock(), createElementBlock("tr", _hoisted_19, [
              createElementVNode("td", {
                class: "w-table__cell",
                colspan: $props.headers.length
              }, [
                createVNode(_component_w_transition_expand, { y: "" }, {
                  default: withCtx(() => [
                    $options.expandedRowsByUid[item._uid] ? (openBlock(), createElementBlock("div", _hoisted_21, [
                      renderSlot(_ctx.$slots, "row-expansion", {
                        item,
                        index: i + 1
                      })
                    ])) : createCommentVNode("", true),
                    i < $props.headers.length - 1 && $props.resizableColumns ? (openBlock(), createElementBlock("span", {
                      key: 1,
                      class: normalizeClass(["w-table__col-resizer", { "w-table__col-resizer--hover": _ctx.colResizing.hover === i, "w-table__col-resizer--active": _ctx.colResizing.columnIndex === _ctx.j }])
                    }, null, 2)) : createCommentVNode("", true)
                  ]),
                  _: 2
                }, 1024)
              ], 8, _hoisted_20)
            ])) : createCommentVNode("", true)
          ], 64);
        }), 128)),
        _ctx.$slots["extra-row"] ? (openBlock(), createElementBlock("div", _hoisted_22, [
          renderSlot(_ctx.$slots, "extra-row")
        ])) : createCommentVNode("", true)
      ]),
      _ctx.$slots.footer || _ctx.$slots["footer-row"] ? (openBlock(), createElementBlock("tfoot", _hoisted_23, [
        _ctx.$slots["footer-row"] ? renderSlot(_ctx.$slots, "footer-row", { key: 0 }) : (openBlock(), createElementBlock("tr", _hoisted_24, [
          createElementVNode("td", {
            class: "w-table__cell",
            colspan: $props.headers.length
          }, [
            renderSlot(_ctx.$slots, "footer")
          ], 8, _hoisted_25)
        ]))
      ])) : createCommentVNode("", true)
    ], 34)
  ], 2);
}
var wTable_vue_vue_type_style_index_0_lang = "";
const minColumnWidth = 15;
const _sfc_main$d = {
  name: "w-table",
  props: {
    items: { type: Array, required: true },
    headers: { type: Array, required: true },
    noHeaders: { type: Boolean },
    fixedLayout: { type: Boolean },
    fixedHeaders: { type: Boolean },
    fixedFooter: { type: Boolean },
    loading: { type: Boolean },
    sort: { type: [String, Array] },
    expandableRows: {
      validator: (value) => {
        if (![void 0, true, false, 1, "1", ""].includes(value)) {
          consoleError(
            `Wrong value for the w-table's \`expandableRows\` prop. Given: "${value}", expected one of: [undefined, true, false, 1, '1', ''].`
          );
        }
        return true;
      }
    },
    expandedRows: { type: Array },
    selectableRows: {
      validator: (value) => {
        if (![void 0, true, false, 1, "1", ""].includes(value)) {
          consoleError(
            `Wrong value for the w-table's \`selectableRows\` prop. Given: "${value}", expected one of: [undefined, true, false, 1, '1', ''].`
          );
        }
        return true;
      }
    },
    selectedRows: { type: Array },
    forceSelection: { type: Boolean },
    uidKey: { type: String, default: "id" },
    filter: { type: Function },
    mobileBreakpoint: { type: Number, default: 0 },
    resizableColumns: { type: Boolean }
  },
  emits: [
    "row-select",
    "row-expand",
    "row-click",
    "update:sort",
    "update:selected-rows",
    "update:expanded-rows",
    "column-resize"
  ],
  data: () => ({
    activeSorting: [],
    selectedRowsInternal: [],
    expandedRowsInternal: [],
    colResizing: {
      dragging: false,
      hover: false,
      columnIndex: null,
      startCursorX: null,
      colWidth: null,
      nextColWidth: null,
      columnEl: null,
      nextColumnEl: null
    }
  }),
  computed: {
    tableItems() {
      return this.items.map((item, i) => {
        item._uid = item[this.uidKey] !== void 0 ? item[this.uidKey] : i;
        return item;
      });
    },
    filteredItems() {
      return typeof this.filter === "function" ? this.tableItems.filter(this.filter) : this.tableItems;
    },
    sortedItems() {
      if (!this.activeSorting.length)
        return this.filteredItems;
      const sortKey1 = this.activeSorting[0].replace(/^[+-]/, "");
      const sortDesc1 = this.activeSorting[0][0] === "-";
      return [...this.filteredItems].sort((a, b) => {
        a = a[sortKey1];
        b = b[sortKey1];
        if (!isNaN(a) && !isNaN(b)) {
          a = parseFloat(a);
          b = parseFloat(b);
        }
        return (a > b ? 1 : -1) * (sortDesc1 ? -1 : 1);
      });
    },
    activeSortingKeys() {
      return this.activeSorting.reduce((obj, item) => {
        obj[item.replace(/^[+-]/, "")] = item[0];
        return obj;
      }, {});
    },
    wrapClasses() {
      return {
        "w-table-wrap--loading": this.loading
      };
    },
    classes() {
      return {
        "w-table--fixed-layout": this.fixedLayout || this.resizableColumns || this.hasStickyColumn,
        "w-table--mobile": this.isMobile || null,
        "w-table--resizable-cols": this.resizableColumns || null,
        "w-table--resizing": this.colResizing.dragging,
        "w-table--fixed-header": this.fixedHeaders,
        "w-table--fixed-footer": this.fixedFooter,
        "w-table--sticky-column": this.hasStickyColumn
      };
    },
    isMobile() {
      return ~~this.mobileBreakpoint && this.$waveui.breakpoint.width <= ~~this.mobileBreakpoint;
    },
    hasStickyColumn() {
      return this.headers.find((header) => header.sticky);
    },
    selectedRowsByUid() {
      return this.selectedRowsInternal.reduce((obj, uid) => (obj[uid] = true) && obj, {});
    },
    expandedRowsByUid() {
      return this.expandedRowsInternal.reduce((obj, uid) => (obj[uid] = true) && obj, {});
    }
  },
  methods: {
    headerClasses(header) {
      return {
        "w-table__header--sortable": header.sortable !== false,
        "w-table__header--sticky": header.sticky,
        "w-table__header--resizable": !!this.resizableColumns,
        [`text-${header.align || "left"}`]: true
      };
    },
    headerSortClasses(header) {
      const headerSorting = this.activeSortingKeys[header.key];
      return [
        `w-table__header-sort--${headerSorting ? "active" : "inactive"}`,
        `w-table__header-sort--${headerSorting === "-" ? "desc" : "asc"}`,
        `m${header.align === "right" ? "r" : "l"}1`
      ];
    },
    sortTable(header) {
      const alreadySortingThis = this.activeSortingKeys[header.key];
      if (alreadySortingThis && this.activeSortingKeys[header.key] === "-") {
        this.activeSorting = [];
        return this.$emit("update:sort");
      } else
        this.activeSorting[0] = (alreadySortingThis ? "-" : "+") + header.key;
      this.$emit("update:sort", this.activeSorting);
    },
    doSelectRow(item, index2) {
      const expandable = this.expandableRows === "" ? true : this.expandableRows;
      const selectable = this.selectableRows === "" ? true : this.selectableRows;
      if (expandable) {
        const isExpanding = this.expandedRowsByUid[item._uid] === void 0;
        if (isExpanding) {
          if (this.expandableRows.toString() === "1")
            this.expandedRowsInternal = [item._uid];
          else
            this.expandedRowsInternal.push(item._uid);
        } else
          this.expandedRowsInternal = this.expandedRowsInternal.filter((uid) => uid !== item._uid);
        this.$emit(
          "row-expand",
          {
            item,
            index: index2,
            expanded: isExpanding,
            expandedRows: this.expandedRowsInternal.map((uid) => this.filteredItems[uid])
          }
        );
        this.$emit("update:expanded-rows", this.expandedRowsInternal);
      } else if (selectable) {
        let updated = false;
        const isSelecting = this.selectedRowsByUid[item._uid] === void 0;
        if (isSelecting) {
          if (this.selectableRows.toString() === "1")
            this.selectedRowsInternal = [item._uid];
          else
            this.selectedRowsInternal.push(item._uid);
          updated = true;
        } else if (!this.forceSelection || this.selectedRowsInternal.length > 1) {
          this.selectedRowsInternal = this.selectedRowsInternal.filter((uid) => uid !== item._uid);
          updated = true;
        }
        if (updated) {
          this.$emit(
            "row-select",
            {
              item,
              index: index2,
              selected: isSelecting,
              selectedRows: this.selectedRowsInternal.map((uid) => this.filteredItems[uid])
            }
          );
          this.$emit("update:selected-rows", this.selectedRowsInternal);
        }
      }
      this.$emit("row-click", { item, index: index2 });
    },
    onMouseDown(e) {
      if (e.target.classList.contains("w-table__col-resizer")) {
        this.colResizing.columnIndex = +e.target.parentNode.cellIndex;
        this.colResizing.startCursorX = e.pageX;
        this.colResizing.columnEl = this.$el.querySelector(`col:nth-child(${this.colResizing.columnIndex + 1})`);
        this.colResizing.nextColumnEl = this.colResizing.columnEl.nextSibling;
        this.colResizing.colWidth = this.colResizing.columnEl.offsetWidth;
        this.colResizing.nextColWidth = this.colResizing.nextColumnEl.offsetWidth;
        document.addEventListener("mousemove", this.onResizerMouseMove);
        document.addEventListener("mouseup", this.onResizerMouseUp);
      }
    },
    onMouseOver({ target }) {
      if (target.classList.contains("w-table__col-resizer")) {
        this.colResizing.hover = +target.parentNode.cellIndex;
      }
    },
    onMouseOut({ target }) {
      if (target.classList.contains("w-table__col-resizer"))
        this.colResizing.hover = false;
    },
    onResizerMouseMove(e) {
      const { startCursorX, columnEl, nextColumnEl, colWidth, nextColWidth } = this.colResizing;
      this.colResizing.dragging = true;
      const deltaX = e.pageX - startCursorX;
      const maxWidth = colWidth + nextColWidth;
      const newColWidth = colWidth + deltaX;
      const newNextColWidth = nextColWidth - deltaX;
      columnEl.style.width = colWidth + deltaX + "px";
      nextColumnEl.style.width = nextColWidth - deltaX + "px";
      const minWidthReached = deltaX < 0 && columnEl.offsetWidth > newColWidth || columnEl.offsetWidth <= minColumnWidth;
      const maxWidthReached = deltaX > 0 && nextColumnEl.offsetWidth > newNextColWidth;
      if (minWidthReached) {
        const newWidth = Math.max(columnEl.offsetWidth, minColumnWidth);
        columnEl.style.width = newWidth + "px";
        nextColumnEl.style.width = maxWidth - newWidth + "px";
      } else if (maxWidthReached) {
        columnEl.style.width = maxWidth - nextColumnEl.offsetWidth + "px";
        nextColumnEl.style.width = nextColumnEl.offsetWidth + "px";
      }
    },
    onResizerMouseUp() {
      document.removeEventListener("mousemove", this.onResizerMouseMove);
      document.removeEventListener("mouseup", this.onResizerMouseUp);
      setTimeout(() => {
        const widths = [...this.$refs.colgroup.childNodes].map((column) => {
          var _a;
          return ((_a = column.style) == null ? void 0 : _a.width) || column.offsetWidth;
        });
        this.$emit("column-resize", { index: this.colResizing.columnIndex, widths });
        this.colResizing.dragging = false;
        this.colResizing.columnIndex = null;
        this.colResizing.startCursorX = null;
        this.colResizing.columnEl = null;
        this.colResizing.nextColumnEl = null;
        this.colResizing.colWidth = null;
        this.colResizing.nextColWidth = null;
      }, 0);
    }
  },
  created() {
    if (!this.sort)
      this.activeSorting = [];
    else
      this.activeSorting = Array.isArray(this.sort) ? this.sort : [this.sort];
    if ((this.expandedRows || []).length)
      this.expandedRowsInternal = this.expandedRows;
    if ((this.selectedRows || []).length)
      this.selectedRowsInternal = this.selectedRows;
  },
  watch: {
    sort(sorting) {
      if (!sorting)
        this.activeSorting = [];
      else
        this.activeSorting = Array.isArray(sorting) ? sorting : [sorting];
    },
    expandableRows(value) {
      if (!value)
        this.expandedRowsInternal = [];
      else if (value.toString() === "1")
        this.expandedRowsInternal = this.expandedRowsInternal.slice(0, 1);
    },
    expandedRows(array) {
      this.expandedRowsInternal = Array.isArray(array) && array.length ? this.expandedRows : [];
    },
    selectableRows(value) {
      if (!value)
        this.selectedRowsInternal = [];
      else if (value.toString() === "1")
        this.selectedRowsInternal = this.selectedRowsInternal.slice(0, 1);
    },
    selectedRows(array) {
      this.selectedRowsInternal = Array.isArray(array) && array.length ? this.selectedRows : [];
    }
  }
};
var wTable = /* @__PURE__ */ _export_sfc(_sfc_main$d, [["render", render$d]]);
const _hoisted_1$2 = ["role", "aria-pressed", "tabindex"];
function render$c(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("span", mergeProps({ class: "w-tag" }, toHandlers(_ctx.$attrs, true), {
    onClick: _cache[1] || (_cache[1] = ($event) => {
      _ctx.$emit("update:modelValue", !$props.modelValue);
      _ctx.$emit("input", !$props.modelValue);
    }),
    onKeypress: _cache[2] || (_cache[2] = withKeys(($event) => {
      _ctx.$emit("update:modelValue", !$props.modelValue);
      _ctx.$emit("input", !$props.modelValue);
    }, ["enter"])),
    class: $options.classes,
    role: $props.modelValue !== -1 && "button",
    "aria-pressed": $props.modelValue !== -1 && ($props.modelValue ? "true" : "false"),
    tabindex: $props.modelValue !== -1 && 0,
    style: $options.styles
  }), [
    renderSlot(_ctx.$slots, "default"),
    $props.closable && $props.modelValue ? (openBlock(), createElementBlock("i", {
      key: 0,
      class: "w-icon w-tag__closable wi-cross",
      onClick: _cache[0] || (_cache[0] = withModifiers(($event) => {
        _ctx.$emit("update:modelValue", false);
        _ctx.$emit("input", false);
      }, ["stop"])),
      role: "icon",
      "aria-hidden": "true"
    })) : createCommentVNode("", true)
  ], 16, _hoisted_1$2);
}
var wTag_vue_vue_type_style_index_0_lang = "";
const _sfc_main$c = {
  name: "w-tag",
  props: {
    modelValue: { type: [Boolean, Number], default: -1 },
    color: { type: String },
    bgColor: { type: String },
    dark: { type: Boolean },
    shadow: { type: Boolean },
    tile: { type: Boolean },
    round: { type: Boolean },
    closable: { type: Boolean },
    outline: { type: Boolean },
    noBorder: { type: Boolean },
    xs: { type: Boolean },
    sm: { type: Boolean },
    md: { type: Boolean },
    lg: { type: Boolean },
    xl: { type: Boolean },
    width: { type: [Number, String] },
    height: { type: [Number, String] }
  },
  emits: ["input", "update:modelValue"],
  computed: {
    presetSize() {
      return this.xs && "xs" || this.sm && "sm" || this.lg && "lg" || this.xl && "xl" || "md";
    },
    classes() {
      return {
        [this.color]: this.color,
        [`${this.bgColor}--bg`]: this.bgColor,
        [`size--${this.presetSize}`]: true,
        "w-tag--dark": this.dark && !this.outline,
        "w-tag--clickable": this.modelValue !== -1,
        "w-tag--outline": this.outline,
        "w-tag--no-border": this.noBorder || this.shadow,
        "w-tag--tile": this.tile,
        "w-tag--round": this.round,
        "w-tag--shadow": this.shadow
      };
    },
    styles() {
      return {
        width: (!isNaN(this.width) ? `${this.width}px` : this.width) || null,
        height: (!isNaN(this.height) ? `${this.height}px` : this.height) || null
      };
    }
  }
};
var wTag = /* @__PURE__ */ _export_sfc(_sfc_main$c, [["render", render$c]]);
const _hoisted_1$1 = ["for"];
const _hoisted_2$1 = ["id", "name", "placeholder", "rows", "cols", "readonly", "aria-readonly", "disabled", "required", "tabindex"];
const _hoisted_3$1 = ["for"];
const _hoisted_4 = ["for"];
function render$b(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_w_icon = resolveComponent("w-icon");
  return openBlock(), createBlock(resolveDynamicComponent(_ctx.formRegister ? "w-form-element" : "div"), mergeProps({ ref: "formEl" }, _ctx.formRegister && { validators: _ctx.validators, inputValue: $data.inputValue, disabled: _ctx.isDisabled, readonly: _ctx.isReadonly, isFocused: $data.isFocused }, {
    valid: _ctx.valid,
    "onUpdate:valid": _cache[6] || (_cache[6] = ($event) => _ctx.valid = $event),
    wrap: $options.hasLabel && $props.labelPosition !== "inside",
    onReset: _cache[7] || (_cache[7] = ($event) => {
      _ctx.$emit("update:modelValue", $data.inputValue = "");
      _ctx.$emit("input", "");
    }),
    class: $options.classes
  }), {
    default: withCtx(() => [
      $props.labelPosition === "left" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
        _ctx.$slots.default || $props.label ? (openBlock(), createElementBlock("label", {
          key: 0,
          class: normalizeClass(["w-textarea__label w-textarea__label--left w-form-el-shakable", _ctx.labelClasses]),
          for: `w-textarea--${_ctx._.uid}`
        }, [
          renderSlot(_ctx.$slots, "default", {}, () => [
            createTextVNode(toDisplayString($props.label), 1)
          ])
        ], 10, _hoisted_1$1)) : createCommentVNode("", true)
      ], 64)) : createCommentVNode("", true),
      createElementVNode("div", {
        class: normalizeClass(["w-textarea__textarea-wrap", $options.inputWrapClasses])
      }, [
        $props.innerIconLeft ? (openBlock(), createBlock(_component_w_icon, {
          key: 0,
          class: "w-textarea__icon w-textarea__icon--inner-left",
          tag: "label",
          for: `w-textarea--${_ctx._.uid}`,
          onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click:inner-icon-left", $event))
        }, {
          default: withCtx(() => [
            createTextVNode(toDisplayString($props.innerIconLeft), 1)
          ]),
          _: 1
        }, 8, ["for"])) : createCommentVNode("", true),
        withDirectives(createElementVNode("textarea", mergeProps({
          class: "w-textarea__textarea",
          ref: "textarea",
          "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => $data.inputValue = $event)
        }, toHandlers($options.listeners, true), {
          onInput: _cache[2] || (_cache[2] = (...args) => $options.onInput && $options.onInput(...args)),
          onFocus: _cache[3] || (_cache[3] = (...args) => $options.onFocus && $options.onFocus(...args)),
          onBlur: _cache[4] || (_cache[4] = (...args) => $options.onBlur && $options.onBlur(...args)),
          id: `w-textarea--${_ctx._.uid}`,
          name: _ctx.inputName,
          placeholder: $props.placeholder || null,
          rows: $props.rows || null,
          cols: $props.cols || null,
          readonly: _ctx.isReadonly || null,
          "aria-readonly": _ctx.isReadonly ? "true" : "false",
          disabled: _ctx.isDisabled || null,
          required: _ctx.required || null,
          tabindex: _ctx.tabindex || null
        }), null, 16, _hoisted_2$1), [
          [vModelText, $data.inputValue]
        ]),
        $props.labelPosition === "inside" && $options.showLabelInside ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
          _ctx.$slots.default || $props.label ? (openBlock(), createElementBlock("label", {
            key: 0,
            class: normalizeClass(["w-textarea__label w-textarea__label--inside w-form-el-shakable", _ctx.labelClasses]),
            for: `w-textarea--${_ctx._.uid}`
          }, [
            renderSlot(_ctx.$slots, "default", {}, () => [
              createTextVNode(toDisplayString($props.label), 1)
            ])
          ], 10, _hoisted_3$1)) : createCommentVNode("", true)
        ], 64)) : createCommentVNode("", true),
        $props.innerIconRight ? (openBlock(), createBlock(_component_w_icon, {
          key: 2,
          class: "w-textarea__icon w-textarea__icon--inner-right",
          tag: "label",
          for: `w-textarea--${_ctx._.uid}`,
          onClick: _cache[5] || (_cache[5] = ($event) => _ctx.$emit("click:inner-icon-right", $event))
        }, {
          default: withCtx(() => [
            createTextVNode(toDisplayString($props.innerIconRight), 1)
          ]),
          _: 1
        }, 8, ["for"])) : createCommentVNode("", true)
      ], 2),
      $props.labelPosition === "right" ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
        _ctx.$slots.default || $props.label ? (openBlock(), createElementBlock("label", {
          key: 0,
          class: normalizeClass(["w-textarea__label w-textarea__label--right w-form-el-shakable", _ctx.labelClasses]),
          for: `w-textarea--${_ctx._.uid}`
        }, [
          renderSlot(_ctx.$slots, "default", {}, () => [
            createTextVNode(toDisplayString($props.label), 1)
          ])
        ], 10, _hoisted_4)) : createCommentVNode("", true)
      ], 64)) : createCommentVNode("", true)
    ]),
    _: 3
  }, 16, ["valid", "wrap", "class"]);
}
var wTextarea_vue_vue_type_style_index_0_lang = "";
const _sfc_main$b = {
  name: "w-textarea",
  mixins: [FormElementMixin],
  props: {
    modelValue: { default: "" },
    label: { type: String },
    labelPosition: { type: String, default: "inside" },
    innerIconLeft: { type: String },
    innerIconRight: { type: String },
    staticLabel: { type: Boolean },
    placeholder: { type: String },
    color: { type: String, default: "primary" },
    bgColor: { type: String },
    labelColor: { type: String, default: "primary" },
    dark: { type: Boolean },
    outline: { type: Boolean },
    shadow: { type: Boolean },
    noAutogrow: { type: Boolean },
    resizable: { type: Boolean },
    tile: { type: Boolean },
    rows: { type: [Number, String], default: 3 },
    cols: { type: [Number, String] }
  },
  emits: ["input", "update:modelValue", "focus", "blur", "click:inner-icon-left", "click:inner-icon-right"],
  data() {
    return {
      inputValue: this.modelValue,
      isFocused: false,
      height: null,
      lineHeight: null,
      paddingY: null
    };
  },
  computed: {
    listeners() {
      const { input, focus, blur, ...listeners } = this.$attrs;
      return listeners;
    },
    hasValue() {
      return this.inputValue || this.inputValue === 0;
    },
    hasLabel() {
      return this.label || this.$slots.default;
    },
    showLabelInside() {
      return !this.staticLabel || !this.hasValue && !this.placeholder;
    },
    classes() {
      return {
        "w-textarea": true,
        "w-textarea--disabled": this.isDisabled,
        "w-textarea--readonly": this.isReadonly,
        [`w-textarea--${this.hasValue ? "filled" : "empty"}`]: true,
        "w-textarea--focused": this.isFocused && !this.isReadonly,
        "w-textarea--dark": this.dark,
        "w-textarea--resizable": this.resizable,
        "w-textarea--floating-label": this.hasLabel && this.labelPosition === "inside" && !this.staticLabel,
        "w-textarea--no-padding": !this.outline && !this.bgColor && !this.shadow,
        "w-textarea--has-placeholder": this.placeholder,
        "w-textarea--inner-icon-left": this.innerIconLeft,
        "w-textarea--inner-icon-right": this.innerIconRight
      };
    },
    inputWrapClasses() {
      return {
        [this.valid === false ? this.validationColor : this.color]: this.color || this.valid === false,
        [`${this.bgColor}--bg`]: this.bgColor,
        "w-textarea__textarea-wrap--tile": this.tile,
        "w-textarea__textarea-wrap--box": this.outline || this.bgColor || this.shadow,
        "w-textarea__textarea-wrap--underline": !this.outline,
        "w-textarea__textarea-wrap--shadow": this.shadow,
        "w-textarea__textarea-wrap--no-padding": !this.outline && !this.bgColor && !this.shadow
      };
    },
    textareaStyles() {
      if (this.noAutogrow || this.resizable)
        return {};
      return {
        height: this.height ? `${this.height}px` : null
      };
    }
  },
  methods: {
    onInput() {
      if (!this.noAutogrow && !this.resizable)
        this.computeHeight();
      this.$emit("update:modelValue", this.inputValue);
      this.$emit("input", this.inputValue);
    },
    onFocus(e) {
      this.isFocused = true;
      this.$emit("focus", e);
    },
    onBlur(e) {
      this.isFocused = false;
      this.$emit("blur", e);
    },
    computeHeight() {
      this.$refs.textarea.style.height = "";
      const linesCount = (this.$refs.textarea.scrollHeight - this.paddingY) / this.lineHeight;
      const height = Math.max(linesCount, this.rows) * this.lineHeight + this.paddingY;
      this.$refs.textarea.style.height = height + "px";
    },
    getLineHeight() {
      const computedStyles = window.getComputedStyle(this.$refs.textarea, null);
      this.lineHeight = parseFloat(computedStyles.getPropertyValue("line-height"));
      this.paddingY = parseFloat(computedStyles.getPropertyValue("padding-top"));
      this.paddingY += parseFloat(computedStyles.getPropertyValue("padding-bottom"));
    }
  },
  mounted() {
    if (!this.noAutogrow && !this.resizable) {
      this.getLineHeight();
      this.computeHeight();
    }
  },
  watch: {
    modelValue(value) {
      this.inputValue = value;
      this.$nextTick(this.computeHeight);
    },
    resizable(value) {
      if (value)
        this.height = null;
      else if (!this.noAutogrow)
        this.getLineHeight();
    },
    noAutogrow(value) {
      if (value)
        this.getLineHeight();
      else
        this.height = null;
    }
  }
};
var wTextarea = /* @__PURE__ */ _export_sfc(_sfc_main$b, [["render", render$b]]);
const _hoisted_1 = { class: "w-timeline" };
const _hoisted_2 = ["innerHTML"];
const _hoisted_3 = ["innerHTML"];
function render$a(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("ul", _hoisted_1, [
    (openBlock(true), createElementBlock(Fragment, null, renderList($props.items, (item, i) => {
      return openBlock(), createElementBlock("li", {
        class: "w-timeline-item",
        key: i
      }, [
        (openBlock(), createBlock(resolveDynamicComponent(item[$props.itemIconKey] || $props.icon ? "w-icon" : "div"), {
          class: normalizeClass(["w-timeline-item__bullet", { [item[$props.itemColorKey] || $props.color]: item[$props.itemColorKey] || $props.color }])
        }, {
          default: withCtx(() => [
            createTextVNode(toDisplayString(item[$props.itemIconKey] || $props.icon), 1)
          ]),
          _: 2
        }, 1032, ["class"])),
        !_ctx.$slots[`item.${i + 1}`] ? renderSlot(_ctx.$slots, "item", {
          key: 0,
          item,
          index: i + 1
        }, () => [
          createElementVNode("div", {
            class: normalizeClass(["w-timeline-item__title", { [item[$props.itemColorKey] || $props.color]: item[$props.itemColorKey] || $props.color }]),
            innerHTML: item[$props.itemTitleKey]
          }, null, 10, _hoisted_2),
          createElementVNode("div", {
            class: "w-timeline-item__content",
            innerHTML: item[$props.itemContentKey]
          }, null, 8, _hoisted_3)
        ]) : renderSlot(_ctx.$slots, `item.${i + 1}`, {
          key: 1,
          item,
          index: i + 1
        })
      ]);
    }), 128))
  ]);
}
var wTimeline_vue_vue_type_style_index_0_lang = "";
const _sfc_main$a = {
  name: "w-timeline",
  props: {
    items: { type: [Array, Number], required: true },
    color: { type: String },
    icon: { type: String },
    itemTitleKey: { type: String, default: "title" },
    itemContentKey: { type: String, default: "content" },
    itemIconKey: { type: String, default: "icon" },
    itemColorKey: { type: String, default: "color" }
  },
  emits: []
};
var wTimeline = /* @__PURE__ */ _export_sfc(_sfc_main$a, [["render", render$a]]);
function render$9(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["w-toolbar", $options.classes]),
    style: normalizeStyle($options.styles)
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 6);
}
var wToolbar_vue_vue_type_style_index_0_lang = "";
const _sfc_main$9 = {
  name: "w-toolbar",
  props: {
    color: { type: String },
    bgColor: { type: String },
    absolute: { type: Boolean },
    fixed: { type: Boolean },
    bottom: { type: Boolean },
    vertical: { type: Boolean },
    left: { type: Boolean },
    right: { type: Boolean },
    width: { type: [Number, String], default: null },
    height: { type: [Number, String], default: null },
    noBorder: { type: Boolean },
    shadow: { type: Boolean }
  },
  emits: [],
  computed: {
    toolbarHeight() {
      const h = this.height;
      return h && parseInt(h) == h ? h + "px" : h;
    },
    toolbarWidth() {
      const w = this.width;
      return w && parseInt(w) == w ? w + "px" : w;
    },
    classes() {
      return {
        [this.color]: !!this.color,
        [`${this.bgColor}--bg`]: !!this.bgColor,
        "w-toolbar--absolute": !!this.absolute,
        "w-toolbar--fixed": !!this.fixed,
        [`w-toolbar--${this.bottom ? "bottom" : "top"}`]: !this.vertical,
        [`w-toolbar--vertical w-toolbar--${this.right ? "right" : "left"}`]: this.vertical,
        "w-toolbar--no-border": this.noBorder,
        "w-toolbar--shadow": !!this.shadow
      };
    },
    styles() {
      return {
        height: this.height && !this.vertical ? this.toolbarHeight : null,
        width: this.width && this.vertical ? this.toolbarWidth : null
      };
    }
  }
};
var wToolbar = /* @__PURE__ */ _export_sfc(_sfc_main$9, [["render", render$9]]);
function render$8(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock(Fragment, null, [
    renderSlot(_ctx.$slots, "activator", { on: $options.activatorEventHandlers }),
    createVNode(Transition, {
      name: $options.transitionName,
      appear: ""
    }, {
      default: withCtx(() => [
        _ctx.detachableVisible ? (openBlock(), createElementBlock("div", {
          class: normalizeClass(["w-tooltip", $options.classes]),
          ref: "detachable",
          key: _ctx._.uid,
          style: normalizeStyle($options.styles)
        }, [
          renderSlot(_ctx.$slots, "default")
        ], 6)) : createCommentVNode("", true)
      ]),
      _: 3
    }, 8, ["name"])
  ], 64);
}
var wTooltip_vue_vue_type_style_index_0_lang = "";
const _sfc_main$8 = {
  name: "w-tooltip",
  mixins: [DetachableMixin],
  props: {
    modelValue: {},
    showOnClick: { type: Boolean },
    color: { type: String },
    bgColor: { type: String },
    noBorder: { type: Boolean },
    shadow: { type: Boolean },
    tile: { type: Boolean },
    round: { type: Boolean },
    transition: { type: String },
    tooltipClass: { type: [String, Object, Array] },
    persistent: { type: Boolean },
    delay: { type: Number }
  },
  emits: ["input", "update:modelValue", "open", "close"],
  data: () => ({
    detachableVisible: false,
    hoveringActivator: false,
    detachableCoords: {
      top: 0,
      left: 0
    },
    detachableEl: null,
    timeoutId: null
  }),
  computed: {
    tooltipClasses() {
      return objectifyClasses(this.tooltipClass);
    },
    transitionName() {
      const direction = this.position.replace(/top|bottom/, (m) => ({ top: "up", bottom: "down" })[m]);
      return this.transition || `w-tooltip-slide-fade-${direction}`;
    },
    classes() {
      return {
        [this.color]: this.color,
        [`${this.bgColor}--bg`]: this.bgColor,
        ...this.tooltipClasses,
        [`w-tooltip--${this.position}`]: !this.noPosition,
        [`w-tooltip--align-${this.alignment}`]: !this.noPosition && this.alignment,
        "w-tooltip--tile": this.tile,
        "w-tooltip--round": this.round,
        "w-tooltip--shadow": this.shadow,
        "w-tooltip--fixed": this.fixed,
        "w-tooltip--no-border": this.noBorder || this.bgColor,
        "w-tooltip--custom-transition": this.transition
      };
    },
    styles() {
      return {
        zIndex: this.zIndex || this.zIndex === 0 || null,
        top: this.detachableCoords.top && `${~~this.detachableCoords.top}px` || null,
        left: this.detachableCoords.left && `${~~this.detachableCoords.left}px` || null,
        "--w-tooltip-bg-color": this.$waveui.colors[this.bgColor || "white"]
      };
    },
    activatorEventHandlers() {
      let handlers = {};
      if (this.showOnClick)
        handlers = { click: this.toggle };
      else {
        handlers = {
          focus: this.toggle,
          blur: this.toggle,
          mouseenter: (e) => {
            this.hoveringActivator = true;
            this.open(e);
          },
          mouseleave: (e) => {
            this.hoveringActivator = false;
            this.close();
          }
        };
        if (typeof window !== "undefined" && "ontouchstart" in window)
          handlers.click = this.toggle;
      }
      return handlers;
    }
  },
  methods: {
    toggle(e) {
      let shouldShowTooltip = this.detachableVisible;
      if (typeof window !== "undefined" && "ontouchstart" in window) {
        if (e.type === "click")
          shouldShowTooltip = !shouldShowTooltip;
      } else if (e.type === "click" && this.showOnClick)
        shouldShowTooltip = !shouldShowTooltip;
      else if (["mouseenter", "focus"].includes(e.type) && !this.showOnClick)
        shouldShowTooltip = true;
      else if (["mouseleave", "blur"].includes(e.type) && !this.showOnClick)
        shouldShowTooltip = false;
      this.timeoutId = clearTimeout(this.timeoutId);
      if (shouldShowTooltip)
        this.open(e);
      else
        this.close();
    },
    async close(force = false) {
      if (!this.detachableVisible)
        return;
      if (this.showOnHover && !force) {
        await new Promise((resolve) => setTimeout(resolve, 10));
        if (this.showOnHover && this.hoveringActivator)
          return;
      }
      this.$emit("update:modelValue", this.detachableVisible = false);
      this.$emit("input", false);
      this.$emit("close");
      document.removeEventListener("mousedown", this.onOutsideMousedown);
      window.removeEventListener("resize", this.onResize);
    }
  }
};
var wTooltip = /* @__PURE__ */ _export_sfc(_sfc_main$8, [["render", render$8]]);
function render$7(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(Transition, mergeProps({ name: "bounce" }, _ctx.$props), {
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default")
    ]),
    _: 3
  }, 16);
}
const _sfc_main$7 = {
  name: "w-transition-bounce",
  props: {
    appear: { type: Boolean },
    duration: { type: [Number, String] }
  }
};
var wTransitionBounce = /* @__PURE__ */ _export_sfc(_sfc_main$7, [["render", render$7]]);
function render$6(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(Transition, {
    name: "expand",
    mode: "out-in",
    css: false,
    onBeforeAppear: $options.beforeAppear,
    onAppear: $options.appear,
    onAfterAppear: $options.afterAppear,
    onBeforeEnter: $options.beforeEnter,
    onEnter: $options.enter,
    onAfterEnter: $options.afterEnter,
    onBeforeLeave: $options.beforeLeave,
    onLeave: $options.leave,
    onAfterLeave: $options.afterLeave
  }, {
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default")
    ]),
    _: 3
  }, 8, ["onBeforeAppear", "onAppear", "onAfterAppear", "onBeforeEnter", "onEnter", "onAfterEnter", "onBeforeLeave", "onLeave", "onAfterLeave"]);
}
const _sfc_main$6 = {
  name: "w-transition-expand",
  props: {
    x: { type: Boolean },
    y: { type: Boolean },
    duration: { type: Number, default: 250 }
  },
  data: () => ({
    el: {
      originalStyles: "",
      width: 0,
      height: 0,
      marginLeft: 0,
      marginRight: 0,
      marginTop: 0,
      marginBottom: 0,
      paddingLeft: 0,
      paddingRight: 0,
      paddingTop: 0,
      paddingBottom: 0,
      borderLeftWidth: 0,
      borderRightWidth: 0,
      borderTopWidth: 0,
      borderBottomWidth: 0
    },
    cleanTransitionCycle: true
  }),
  computed: {
    animX() {
      return this.x || !this.y;
    },
    animY() {
      return this.y || !this.x;
    }
  },
  methods: {
    beforeAppear(el) {
      if (this.cleanTransitionCycle)
        this.saveOriginalStyles(el);
      this.cleanTransitionCycle = false;
    },
    appear(el, done) {
      this.show(el);
      setTimeout(done, this.duration);
      this.cleanTransitionCycle = false;
    },
    afterAppear(el) {
      this.applyOriginalStyles(el);
      el.style.cssText = el.style.cssText.replace("display: none;", "");
      this.cleanTransitionCycle = false;
    },
    beforeEnter(el) {
      if (this.cleanTransitionCycle)
        this.saveOriginalStyles(el);
      this.cleanTransitionCycle = false;
    },
    enter(el, done) {
      this.show(el);
      setTimeout(done, this.duration);
      this.cleanTransitionCycle = false;
    },
    afterEnter(el) {
      this.applyOriginalStyles(el);
      el.style.cssText = el.style.cssText.replace("display: none;", "");
      this.cleanTransitionCycle = false;
    },
    beforeLeave(el) {
      this.beforeHide(el);
      this.cleanTransitionCycle = false;
    },
    leave(el, done) {
      this.hide(el);
      setTimeout(done, this.duration);
      this.cleanTransitionCycle = false;
    },
    afterLeave(el) {
      this.applyOriginalStyles(el);
      this.cleanTransitionCycle = true;
    },
    applyHideStyles(el) {
      if (this.animX) {
        el.style.width = 0;
        el.style.marginLeft = 0;
        el.style.marginRight = 0;
        el.style.paddingLeft = 0;
        el.style.paddingRight = 0;
        el.style.borderLeftWidth = 0;
        el.style.borderRightWidth = 0;
      }
      if (this.animY) {
        el.style.height = 0;
        el.style.marginTop = 0;
        el.style.marginBottom = 0;
        el.style.paddingTop = 0;
        el.style.paddingBottom = 0;
        el.style.borderTopWidth = 0;
        el.style.borderBottomWidth = 0;
      }
      el.style.overflow = "hidden";
    },
    applyShowStyles(el) {
      if (this.animX) {
        el.style.width = this.el.width + "px";
        el.style.marginLeft = this.el.marginLeft;
        el.style.marginRight = this.el.marginRight;
        el.style.paddingLeft = this.el.paddingLeft;
        el.style.paddingRight = this.el.paddingRight;
        el.style.borderLeftWidth = this.el.borderLeftWidth;
        el.style.borderRightWidth = this.el.borderRightWidth;
      }
      if (this.animY) {
        el.style.height = this.el.height + "px";
        el.style.marginTop = this.el.marginTop;
        el.style.marginBottom = this.el.marginBottom;
        el.style.paddingTop = this.el.paddingTop;
        el.style.paddingBottom = this.el.paddingBottom;
        el.style.borderTopWidth = this.el.borderTopWidth;
        el.style.borderBottomWidth = this.el.borderBottomWidth;
      }
      el.style.transition = this.duration + "ms ease-in-out";
    },
    applyOriginalStyles(el) {
      el.style.cssText = this.el.originalStyles;
    },
    saveOriginalStyles(el) {
      this.el.originalStyles = el.style.cssText;
    },
    show(el, done) {
      const computedStyles = window.getComputedStyle(el, null);
      if (this.animX) {
        this.el.width = el.offsetWidth;
        this.el.marginLeft = computedStyles.getPropertyValue("marginLeft");
        this.el.marginRight = computedStyles.getPropertyValue("marginRight");
        this.el.paddingLeft = computedStyles.getPropertyValue("paddingLeft");
        this.el.paddingRight = computedStyles.getPropertyValue("paddingRight");
        this.el.borderLeftWidth = computedStyles.getPropertyValue("borderLeftWidth");
        this.el.borderRightWidth = computedStyles.getPropertyValue("borderRightWidth");
      }
      if (this.animY) {
        this.el.height = el.offsetHeight;
        this.el.marginTop = computedStyles.getPropertyValue("marginTop");
        this.el.marginBottom = computedStyles.getPropertyValue("marginBottom");
        this.el.paddingTop = computedStyles.getPropertyValue("paddingTop");
        this.el.paddingBottom = computedStyles.getPropertyValue("paddingBottom");
        this.el.borderTopWidth = computedStyles.getPropertyValue("borderTopWidth");
        this.el.borderBottomWidth = computedStyles.getPropertyValue("borderBottomWidth");
      }
      this.applyHideStyles(el);
      setTimeout(() => this.applyShowStyles(el), 20);
      setTimeout(done, this.duration);
    },
    beforeHide(el) {
      this.applyShowStyles(el);
    },
    hide(el, done) {
      setTimeout(() => this.applyHideStyles(el), 20);
      setTimeout(done, this.duration);
    }
  }
};
var wTransitionExpand = /* @__PURE__ */ _export_sfc(_sfc_main$6, [["render", render$6]]);
function render$5(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(Transition, mergeProps({ name: "fade" }, _ctx.$props), {
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default")
    ]),
    _: 3
  }, 16);
}
const _sfc_main$5 = {
  name: "w-transition-fade",
  props: {
    appear: { type: Boolean },
    duration: { type: [Number, String] }
  }
};
var wTransitionFade = /* @__PURE__ */ _export_sfc(_sfc_main$5, [["render", render$5]]);
function render$4(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(Transition, mergeProps({ name: "scale" }, _ctx.$props), {
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default")
    ]),
    _: 3
  }, 16);
}
const _sfc_main$4 = {
  name: "w-transition-scale",
  props: {
    appear: { type: Boolean },
    duration: { type: [Number, String] }
  }
};
var wTransitionScale = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["render", render$4]]);
function render$3(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(Transition, mergeProps({ name: "scale-fade" }, _ctx.$props), {
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default")
    ]),
    _: 3
  }, 16);
}
const _sfc_main$3 = {
  name: "w-transition-scale-fade",
  props: {
    appear: { type: Boolean },
    duration: { type: [Number, String] }
  }
};
var wTransitionScaleFade = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["render", render$3]]);
function render$2(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(Transition, mergeProps({ name: $options.transitionName }, _ctx.$props), {
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default")
    ]),
    _: 3
  }, 16, ["name"]);
}
const _sfc_main$2 = {
  name: "w-transition-slide",
  props: {
    appear: { type: Boolean },
    left: { type: Boolean },
    right: { type: Boolean },
    up: { type: Boolean },
    down: { type: Boolean },
    duration: { type: [Number, String] }
  },
  computed: {
    direction() {
      return this.up && "up" || this.down && "down" || this.left && "left" || this.right && "right" || "down";
    },
    transitionName() {
      return `slide-${this.direction}`;
    }
  }
};
var wTransitionSlide = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["render", render$2]]);
function render$1(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(Transition, mergeProps({ name: $options.transitionName }, _ctx.$props), {
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default")
    ]),
    _: 3
  }, 16, ["name"]);
}
const _sfc_main$1 = {
  name: "w-transition-slide-fade",
  props: {
    appear: { type: Boolean },
    left: { type: Boolean },
    right: { type: Boolean },
    up: { type: Boolean },
    down: { type: Boolean },
    duration: { type: [Number, String] }
  },
  computed: {
    direction() {
      return this.up && "up" || this.down && "down" || this.left && "left" || this.right && "right" || "down";
    },
    transitionName() {
      return `slide-fade-${this.direction}`;
    }
  }
};
var wTransitionSlideFade = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["render", render$1]]);
function render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(Transition, mergeProps({ name: "twist" }, _ctx.$props), {
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default")
    ]),
    _: 3
  }, 16);
}
const _sfc_main = {
  name: "w-transition-twist",
  props: {
    appear: { type: Boolean },
    duration: { type: [Number, String] }
  }
};
var wTransitionTwist = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", render]]);
var components = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  WAccordion: wAccordion,
  WAlert: wAlert,
  WApp: wApp,
  WBadge: wBadge,
  WBreadcrumbs: wBreadcrumbs,
  WButton: wButton,
  WCard: wCard,
  WCheckbox: wCheckbox,
  WCheckboxes: wCheckboxes,
  WConfirm: wConfirm,
  WDatePicker: wDatePicker,
  WDialog: wDialog,
  WDivider: wDivider,
  WDrawer: wDrawer,
  WFlex: wFlex,
  WForm: wForm,
  WFormElement: wFormElement,
  WGrid: wGrid,
  WIcon: wIcon,
  WImage: wImage,
  WInput: wInput,
  WList: wList,
  WMenu: wMenu,
  WNotification: wNotification,
  WOverlay: wOverlay,
  WParallax: wParallax,
  WProgress: wProgress,
  WRadio: wRadio,
  WRadios: wRadios,
  WRating: wRating,
  WSelect: wSelect,
  WSlider: wSlider,
  WSpinner: wSpinner,
  WSteps: wSteps,
  WSwitch: wSwitch,
  WTabs: index,
  WTable: wTable,
  WTag: wTag,
  WTextarea: wTextarea,
  WTimeline: wTimeline,
  WToolbar: wToolbar,
  WTooltip: wTooltip,
  WTransitionBounce: wTransitionBounce,
  WTransitionExpand: wTransitionExpand,
  WTransitionFade: wTransitionFade,
  WTransitionScale: wTransitionScale,
  WTransitionScaleFade: wTransitionScaleFade,
  WTransitionSlide: wTransitionSlide,
  WTransitionSlideFade: wTransitionSlideFade,
  WTransitionTwist: wTransitionTwist
}, Symbol.toStringTag, { value: "Module" }));
const install = WaveUI.install;
WaveUI.install = (app, options = {}) => install.call(WaveUI, app, { components, ...options });
export { WaveUI as default };
